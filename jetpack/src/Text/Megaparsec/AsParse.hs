module Text.Megaparsec.AsParse
  ( -- unqualified class re-export
  (I.<|>), I.some, I.many, I.failure, I.label, I.hidden, I.try, I.lookAhead, I.notFollowedBy, I.eof, I.token, I.tokens, I.getParserState, I.updateParserState, I.StorableStream(I.fromFile), I.Stream(I.uncons)
  , module Text.Megaparsec.AsParse
  ) where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import qualified Text.Megaparsec as I


-- parse_optional :: forall (f :: * -> *) a. Alternative f => f a -> f (Maybe a)
parse_optional = I.optional

-- parse_alphaNumChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_alphaNumChar = I.alphaNumChar

-- parse_anyChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_anyChar = I.anyChar

-- parse_asciiChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_asciiChar = I.asciiChar

-- parse_char :: forall (m :: * -> *) s. MonadParsec s m Char => Char -> m Char
parse_char = I.char

-- parse_char' :: forall (m :: * -> *) s. MonadParsec s m Char => Char -> m Char
parse_char' = I.char'

-- parse_charCategory :: forall (m :: * -> *) s. MonadParsec s m Char => GeneralCategory -> m Char
parse_charCategory = I.charCategory

-- parse_controlChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_controlChar = I.controlChar

-- parse_crlf :: forall (m :: * -> *) s. MonadParsec s m Char => m String
parse_crlf = I.crlf

-- parse_digitChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_digitChar = I.digitChar

-- parse_eol :: forall (m :: * -> *) s. MonadParsec s m Char => m String
parse_eol = I.eol

-- parse_hexDigitChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_hexDigitChar = I.hexDigitChar

-- parse_latin1Char :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_latin1Char = I.latin1Char

-- parse_letterChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_letterChar = I.letterChar

-- parse_lowerChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_lowerChar = I.lowerChar

-- parse_markChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_markChar = I.markChar

-- parse_newline :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_newline = I.newline

-- parse_noneOf :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
parse_noneOf = I.noneOf

-- parse_noneOf' :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
parse_noneOf' = I.noneOf'

-- parse_numberChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_numberChar = I.numberChar

-- parse_octDigitChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_octDigitChar = I.octDigitChar

-- parse_oneOf :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
parse_oneOf = I.oneOf

-- parse_oneOf' :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
parse_oneOf' = I.oneOf'

-- parse_printChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_printChar = I.printChar

-- parse_punctuationChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_punctuationChar = I.punctuationChar

-- parse_satisfy :: forall (m :: * -> *) s. MonadParsec s m Char => (Char -> Bool) -> m Char
parse_satisfy = I.satisfy

-- parse_separatorChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_separatorChar = I.separatorChar

-- parse_space :: forall (m :: * -> *) s. MonadParsec s m Char => m ()
parse_space = I.space

-- parse_spaceChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_spaceChar = I.spaceChar

-- parse_string :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m String
parse_string = I.string

-- parse_string' :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m String
parse_string' = I.string'

-- parse_symbolChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_symbolChar = I.symbolChar

-- parse_tab :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_tab = I.tab

-- parse_upperChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
parse_upperChar = I.upperChar

-- parse_between :: forall (m :: * -> *) open close a. Applicative m => m open -> m close -> m a -> m a
parse_between = I.between

-- parse_choice :: forall (f :: * -> *) (m :: * -> *) a. (Foldable f, Alternative m) => f (m a) -> m a
parse_choice = I.choice

-- parse_count :: forall (m :: * -> *) a. Alternative m => Int -> m a -> m [a]
parse_count = I.count

-- parse_count' :: forall (m :: * -> *) a. Alternative m => Int -> Int -> m a -> m [a]
parse_count' = I.count'

-- parse_endBy :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
parse_endBy = I.endBy

-- parse_endBy1 :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
parse_endBy1 = I.endBy1

-- parse_manyTill :: forall (m :: * -> *) a end. Alternative m => m a -> m end -> m [a]
parse_manyTill = I.manyTill

-- parse_option :: forall a (m :: * -> *). Alternative m => a -> m a -> m a
parse_option = I.option

-- parse_sepBy :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
parse_sepBy = I.sepBy

-- parse_sepBy1 :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
parse_sepBy1 = I.sepBy1

-- parse_sepEndBy :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
parse_sepEndBy = I.sepEndBy

-- parse_sepEndBy1 :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
parse_sepEndBy1 = I.sepEndBy1

-- parse_skipMany :: forall (m :: * -> *) a. Alternative m => m a -> m ()
parse_skipMany = I.skipMany

-- parse_skipSome :: forall (m :: * -> *) a. Alternative m => m a -> m ()
parse_skipSome = I.skipSome

-- parse_someTill :: forall (m :: * -> *) a end. Alternative m => m a -> m end -> m [a]
parse_someTill = I.someTill

-- parse_badMessage :: Message -> Bool
parse_badMessage = I.badMessage

-- parse_errorIsUnknown :: ParseError -> Bool
parse_errorIsUnknown = I.errorIsUnknown

-- parse_messageString :: Message -> String
parse_messageString = I.messageString

-- (<?>) :: forall (m :: * -> *) a s t. MonadParsec s m t => m a -> String -> m a
(<?>) = (I.<?>)

-- parse_getInput :: forall (m :: * -> *) s t. MonadParsec s m t => m s
parse_getInput = I.getInput

-- parse_getPosition :: forall (m :: * -> *) s t. MonadParsec s m t => m SourcePos
parse_getPosition = I.getPosition

-- parse_getTabWidth :: forall (m :: * -> *) s t. MonadParsec s m t => m Int
parse_getTabWidth = I.getTabWidth

-- parse_parse :: forall s a t. Stream s t => Parsec s a -> String -> s -> Either ParseError a
parse_parse = I.parse

-- parse_parseFromFile :: forall s a t. StorableStream s t => Parsec s a -> FilePath -> IO (Either ParseError a)
parse_parseFromFile = I.parseFromFile

-- parse_parseMaybe :: forall s a t. Stream s t => Parsec s a -> s -> Maybe a
parse_parseMaybe = I.parseMaybe

-- parse_parseTest :: forall s a t. (Stream s t, Show a) => Parsec s a -> s -> IO ()
parse_parseTest = I.parseTest

-- parse_runParser :: forall s a t. Stream s t => Parsec s a -> String -> s -> Either ParseError a
parse_runParser = I.runParser

-- parse_runParser' :: forall s a t. Stream s t => Parsec s a -> State s -> (State s, Either ParseError a)
parse_runParser' = I.runParser'

-- parse_runParserT :: forall s (m :: * -> *) a t. (Monad m, Stream s t) => ParsecT s m a -> String -> s -> m (Either ParseError a)
parse_runParserT = I.runParserT

-- parse_runParserT' :: forall s (m :: * -> *) a t. (Monad m, Stream s t) => ParsecT s m a -> State s -> m (State s, Either ParseError a)
parse_runParserT' = I.runParserT'

-- parse_setInput :: forall s (m :: * -> *) t. MonadParsec s m t => s -> m ()
parse_setInput = I.setInput

-- parse_setParserState :: forall s (m :: * -> *) t. MonadParsec s m t => State s -> m ()
parse_setParserState = I.setParserState

-- parse_setPosition :: forall (m :: * -> *) s t. MonadParsec s m t => SourcePos -> m ()
parse_setPosition = I.setPosition

-- parse_setTabWidth :: forall (m :: * -> *) s t. MonadParsec s m t => Int -> m ()
parse_setTabWidth = I.setTabWidth

-- parse_unexpected :: forall (m :: * -> *) a s t. MonadParsec s m t => String -> m a
parse_unexpected = I.unexpected

type ParseMessage  = I.Message

-- constructor :: String -> Unexpected
parse_mk'Unexpected =  I.Unexpected
pattern ParseUnexpected a <-  I.Unexpected a

-- constructor :: String -> Expected
parse_mk'Expected =  I.Expected
pattern ParseExpected a <-  I.Expected a

-- constructor :: String -> Message
parse_mk'Message =  I.Message
pattern ParseMessage a <-  I.Message a

type ParseParseError  = I.ParseError

type ParseSourcePos  = I.SourcePos

type ParseParsec a = I.Parsec a

type ParseParsecT a b c = I.ParsecT a b c

type ParseState a = I.State a

-- constructor :: s -> SourcePos -> Int -> State
parse_mk'State =  I.State
pattern ParseState a b c <-  I.State a b c
