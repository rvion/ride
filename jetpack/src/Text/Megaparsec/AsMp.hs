module Text.Megaparsec.AsMp where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import Text.Megaparsec as I

-- mp_optional :: forall (f :: * -> *) a. Alternative f => f a -> f (Maybe a)
mp_optional = I.optional

-- mp_alphaNumChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_alphaNumChar = I.alphaNumChar

-- mp_anyChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_anyChar = I.anyChar

-- mp_asciiChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_asciiChar = I.asciiChar

-- mp_char :: forall (m :: * -> *) s. MonadParsec s m Char => Char -> m Char
mp_char = I.char

-- mp_char' :: forall (m :: * -> *) s. MonadParsec s m Char => Char -> m Char
mp_char' = I.char'

-- mp_charCategory :: forall (m :: * -> *) s. MonadParsec s m Char => GeneralCategory -> m Char
mp_charCategory = I.charCategory

-- mp_controlChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_controlChar = I.controlChar

-- mp_crlf :: forall (m :: * -> *) s. MonadParsec s m Char => m String
mp_crlf = I.crlf

-- mp_digitChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_digitChar = I.digitChar

-- mp_eol :: forall (m :: * -> *) s. MonadParsec s m Char => m String
mp_eol = I.eol

-- mp_hexDigitChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_hexDigitChar = I.hexDigitChar

-- mp_latin1Char :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_latin1Char = I.latin1Char

-- mp_letterChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_letterChar = I.letterChar

-- mp_lowerChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_lowerChar = I.lowerChar

-- mp_markChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_markChar = I.markChar

-- mp_newline :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_newline = I.newline

-- mp_noneOf :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
mp_noneOf = I.noneOf

-- mp_noneOf' :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
mp_noneOf' = I.noneOf'

-- mp_numberChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_numberChar = I.numberChar

-- mp_octDigitChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_octDigitChar = I.octDigitChar

-- mp_oneOf :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
mp_oneOf = I.oneOf

-- mp_oneOf' :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
mp_oneOf' = I.oneOf'

-- mp_printChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_printChar = I.printChar

-- mp_punctuationChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_punctuationChar = I.punctuationChar

-- mp_satisfy :: forall (m :: * -> *) s. MonadParsec s m Char => (Char -> Bool) -> m Char
mp_satisfy = I.satisfy

-- mp_separatorChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_separatorChar = I.separatorChar

-- mp_space :: forall (m :: * -> *) s. MonadParsec s m Char => m ()
mp_space = I.space

-- mp_spaceChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_spaceChar = I.spaceChar

-- mp_string :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m String
mp_string = I.string

-- mp_string' :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m String
mp_string' = I.string'

-- mp_symbolChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_symbolChar = I.symbolChar

-- mp_tab :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_tab = I.tab

-- mp_upperChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_upperChar = I.upperChar

-- mp_between :: forall (m :: * -> *) open close a. Applicative m => m open -> m close -> m a -> m a
mp_between = I.between

-- mp_choice :: forall (f :: * -> *) (m :: * -> *) a. (Foldable f, Alternative m) => f (m a) -> m a
mp_choice = I.choice

-- mp_count :: forall (m :: * -> *) a. Alternative m => Int -> m a -> m [a]
mp_count = I.count

-- mp_count' :: forall (m :: * -> *) a. Alternative m => Int -> Int -> m a -> m [a]
mp_count' = I.count'

-- mp_endBy :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_endBy = I.endBy

-- mp_endBy1 :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_endBy1 = I.endBy1

-- mp_manyTill :: forall (m :: * -> *) a end. Alternative m => m a -> m end -> m [a]
mp_manyTill = I.manyTill

-- mp_option :: forall a (m :: * -> *). Alternative m => a -> m a -> m a
mp_option = I.option

-- mp_sepBy :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_sepBy = I.sepBy

-- mp_sepBy1 :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_sepBy1 = I.sepBy1

-- mp_sepEndBy :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_sepEndBy = I.sepEndBy

-- mp_sepEndBy1 :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_sepEndBy1 = I.sepEndBy1

-- mp_skipMany :: forall (m :: * -> *) a. Alternative m => m a -> m ()
mp_skipMany = I.skipMany

-- mp_skipSome :: forall (m :: * -> *) a. Alternative m => m a -> m ()
mp_skipSome = I.skipSome

-- mp_someTill :: forall (m :: * -> *) a end. Alternative m => m a -> m end -> m [a]
mp_someTill = I.someTill

-- mp_badMessage :: Message -> Bool
mp_badMessage = I.badMessage

-- mp_errorIsUnknown :: ParseError -> Bool
mp_errorIsUnknown = I.errorIsUnknown

-- mp_messageString :: Message -> String
mp_messageString = I.messageString

-- (<?>) :: forall (m :: * -> *) a s t. MonadParsec s m t => m a -> String -> m a
(<?>) = (I.<?>)

-- mp_getInput :: forall (m :: * -> *) s t. MonadParsec s m t => m s
mp_getInput = I.getInput

-- mp_getPosition :: forall (m :: * -> *) s t. MonadParsec s m t => m SourcePos
mp_getPosition = I.getPosition

-- mp_getTabWidth :: forall (m :: * -> *) s t. MonadParsec s m t => m Int
mp_getTabWidth = I.getTabWidth

-- mp_parse :: forall s a t. Stream s t => Parsec s a -> String -> s -> Either ParseError a
mp_parse = I.parse

-- mp_parseFromFile :: forall s a t. StorableStream s t => Parsec s a -> FilePath -> IO (Either ParseError a)
mp_parseFromFile = I.parseFromFile

-- mp_parseMaybe :: forall s a t. Stream s t => Parsec s a -> s -> Maybe a
mp_parseMaybe = I.parseMaybe

-- mp_parseTest :: forall s a t. (Stream s t, Show a) => Parsec s a -> s -> IO ()
mp_parseTest = I.parseTest

-- mp_runParser :: forall s a t. Stream s t => Parsec s a -> String -> s -> Either ParseError a
mp_runParser = I.runParser

-- mp_runParser' :: forall s a t. Stream s t => Parsec s a -> State s -> (State s, Either ParseError a)
mp_runParser' = I.runParser'

-- mp_runParserT :: forall s (m :: * -> *) a t. (Monad m, Stream s t) => ParsecT s m a -> String -> s -> m (Either ParseError a)
mp_runParserT = I.runParserT

-- mp_runParserT' :: forall s (m :: * -> *) a t. (Monad m, Stream s t) => ParsecT s m a -> State s -> m (State s, Either ParseError a)
mp_runParserT' = I.runParserT'

-- mp_setInput :: forall s (m :: * -> *) t. MonadParsec s m t => s -> m ()
mp_setInput = I.setInput

-- mp_setParserState :: forall s (m :: * -> *) t. MonadParsec s m t => State s -> m ()
mp_setParserState = I.setParserState

-- mp_setPosition :: forall (m :: * -> *) s t. MonadParsec s m t => SourcePos -> m ()
mp_setPosition = I.setPosition

-- mp_setTabWidth :: forall (m :: * -> *) s t. MonadParsec s m t => Int -> m ()
mp_setTabWidth = I.setTabWidth

-- mp_unexpected :: forall (m :: * -> *) a s t. MonadParsec s m t => String -> m a
mp_unexpected = I.unexpected

type MpMessage  = I.Message 
type MpParseError  = I.ParseError 
type MpSourcePos  = I.SourcePos 
type MpParsec a = I.Parsec a
type MpParsecT a b c = I.ParsecT a b c
type MpState a = I.State a
