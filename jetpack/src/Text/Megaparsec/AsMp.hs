module Text.Megaparsec.AsMp where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import qualified Text.Megaparsec as I


-- mp_optional :: forall (f :: * -> *) a. Alternative f => f a -> f (Maybe a)
mp_optional = I.optional

-- mp_alphaNumChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_alphaNumChar = I.alphaNumChar

-- mp_anyChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_anyChar = I.anyChar

-- mp_asciiChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_asciiChar = I.asciiChar

-- mp_char :: forall (m :: * -> *) s. MonadParsec s m Char => Char -> m Char
mp_char = I.char

-- mp_char' :: forall (m :: * -> *) s. MonadParsec s m Char => Char -> m Char
mp_char' = I.char'

-- mp_charCategory :: forall (m :: * -> *) s. MonadParsec s m Char => GeneralCategory -> m Char
mp_charCategory = I.charCategory

-- mp_controlChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_controlChar = I.controlChar

-- mp_crlf :: forall (m :: * -> *) s. MonadParsec s m Char => m String
mp_crlf = I.crlf

-- mp_digitChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_digitChar = I.digitChar

-- mp_eol :: forall (m :: * -> *) s. MonadParsec s m Char => m String
mp_eol = I.eol

-- mp_hexDigitChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_hexDigitChar = I.hexDigitChar

-- mp_latin1Char :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_latin1Char = I.latin1Char

-- mp_letterChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_letterChar = I.letterChar

-- mp_lowerChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_lowerChar = I.lowerChar

-- mp_markChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_markChar = I.markChar

-- mp_newline :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_newline = I.newline

-- mp_noneOf :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
mp_noneOf = I.noneOf

-- mp_noneOf' :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
mp_noneOf' = I.noneOf'

-- mp_numberChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_numberChar = I.numberChar

-- mp_octDigitChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_octDigitChar = I.octDigitChar

-- mp_oneOf :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
mp_oneOf = I.oneOf

-- mp_oneOf' :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m Char
mp_oneOf' = I.oneOf'

-- mp_printChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_printChar = I.printChar

-- mp_punctuationChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_punctuationChar = I.punctuationChar

-- mp_satisfy :: forall (m :: * -> *) s. MonadParsec s m Char => (Char -> Bool) -> m Char
mp_satisfy = I.satisfy

-- mp_separatorChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_separatorChar = I.separatorChar

-- mp_space :: forall (m :: * -> *) s. MonadParsec s m Char => m ()
mp_space = I.space

-- mp_spaceChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_spaceChar = I.spaceChar

-- mp_string :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m String
mp_string = I.string

-- mp_string' :: forall (m :: * -> *) s. MonadParsec s m Char => String -> m String
mp_string' = I.string'

-- mp_symbolChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_symbolChar = I.symbolChar

-- mp_tab :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_tab = I.tab

-- mp_upperChar :: forall (m :: * -> *) s. MonadParsec s m Char => m Char
mp_upperChar = I.upperChar

-- mp_between :: forall (m :: * -> *) open close a. Applicative m => m open -> m close -> m a -> m a
mp_between = I.between

-- mp_choice :: forall (f :: * -> *) (m :: * -> *) a. (Foldable f, Alternative m) => f (m a) -> m a
mp_choice = I.choice

-- mp_count :: forall (m :: * -> *) a. Alternative m => Int -> m a -> m [a]
mp_count = I.count

-- mp_count' :: forall (m :: * -> *) a. Alternative m => Int -> Int -> m a -> m [a]
mp_count' = I.count'

-- mp_endBy :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_endBy = I.endBy

-- mp_endBy1 :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_endBy1 = I.endBy1

-- mp_manyTill :: forall (m :: * -> *) a end. Alternative m => m a -> m end -> m [a]
mp_manyTill = I.manyTill

-- mp_option :: forall a (m :: * -> *). Alternative m => a -> m a -> m a
mp_option = I.option

-- mp_sepBy :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_sepBy = I.sepBy

-- mp_sepBy1 :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_sepBy1 = I.sepBy1

-- mp_sepEndBy :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_sepEndBy = I.sepEndBy

-- mp_sepEndBy1 :: forall (m :: * -> *) a sep. Alternative m => m a -> m sep -> m [a]
mp_sepEndBy1 = I.sepEndBy1

-- mp_skipMany :: forall (m :: * -> *) a. Alternative m => m a -> m ()
mp_skipMany = I.skipMany

-- mp_skipSome :: forall (m :: * -> *) a. Alternative m => m a -> m ()
mp_skipSome = I.skipSome

-- mp_someTill :: forall (m :: * -> *) a end. Alternative m => m a -> m end -> m [a]
mp_someTill = I.someTill

-- mp_badMessage :: Message -> Bool
mp_badMessage = I.badMessage

-- mp_errorIsUnknown :: ParseError -> Bool
mp_errorIsUnknown = I.errorIsUnknown

-- mp_messageString :: Message -> String
mp_messageString = I.messageString

-- (<?>) :: forall (m :: * -> *) a s t. MonadParsec s m t => m a -> String -> m a
(<?>) = (I.<?>)

-- mp_getInput :: forall (m :: * -> *) s t. MonadParsec s m t => m s
mp_getInput = I.getInput

-- mp_getPosition :: forall (m :: * -> *) s t. MonadParsec s m t => m SourcePos
mp_getPosition = I.getPosition

-- mp_getTabWidth :: forall (m :: * -> *) s t. MonadParsec s m t => m Int
mp_getTabWidth = I.getTabWidth

-- mp_parse :: forall s a t. Stream s t => Parsec s a -> String -> s -> Either ParseError a
mp_parse = I.parse

-- mp_parseFromFile :: forall s a t. StorableStream s t => Parsec s a -> FilePath -> IO (Either ParseError a)
mp_parseFromFile = I.parseFromFile

-- mp_parseMaybe :: forall s a t. Stream s t => Parsec s a -> s -> Maybe a
mp_parseMaybe = I.parseMaybe

-- mp_parseTest :: forall s a t. (Stream s t, Show a) => Parsec s a -> s -> IO ()
mp_parseTest = I.parseTest

-- mp_runParser :: forall s a t. Stream s t => Parsec s a -> String -> s -> Either ParseError a
mp_runParser = I.runParser

-- mp_runParser' :: forall s a t. Stream s t => Parsec s a -> State s -> (State s, Either ParseError a)
mp_runParser' = I.runParser'

-- mp_runParserT :: forall s (m :: * -> *) a t. (Monad m, Stream s t) => ParsecT s m a -> String -> s -> m (Either ParseError a)
mp_runParserT = I.runParserT

-- mp_runParserT' :: forall s (m :: * -> *) a t. (Monad m, Stream s t) => ParsecT s m a -> State s -> m (State s, Either ParseError a)
mp_runParserT' = I.runParserT'

-- mp_setInput :: forall s (m :: * -> *) t. MonadParsec s m t => s -> m ()
mp_setInput = I.setInput

-- mp_setParserState :: forall s (m :: * -> *) t. MonadParsec s m t => State s -> m ()
mp_setParserState = I.setParserState

-- mp_setPosition :: forall (m :: * -> *) s t. MonadParsec s m t => SourcePos -> m ()
mp_setPosition = I.setPosition

-- mp_setTabWidth :: forall (m :: * -> *) s t. MonadParsec s m t => Int -> m ()
mp_setTabWidth = I.setTabWidth

-- mp_unexpected :: forall (m :: * -> *) a s t. MonadParsec s m t => String -> m a
mp_unexpected = I.unexpected

-- (<|>) :: forall a. f a -> f a -> f a
(<|>) = (I.<|>)

-- mp_some :: forall a. f a -> f [a]
mp_some = I.some

-- mp_many :: forall a. f a -> f [a]
mp_many = I.many

type MpMessage  = I.Message

-- constructor :: String -> Unexpected
mp_mk'Unexpected =  I.Unexpected
pattern MpUnexpected a <-  I.Unexpected a

-- constructor :: String -> Expected
mp_mk'Expected =  I.Expected
pattern MpExpected a <-  I.Expected a

-- constructor :: String -> Message
mp_mk'Message =  I.Message
pattern MpMessage a <-  I.Message a

type MpParseError  = I.ParseError

type MpSourcePos  = I.SourcePos

-- mp_failure :: forall a. [Message] -> m a
mp_failure = I.failure

-- mp_label :: forall a. String -> m a -> m a
mp_label = I.label

-- mp_hidden :: forall a. m a -> m a
mp_hidden = I.hidden

-- mp_try :: forall a. m a -> m a
mp_try = I.try

-- mp_lookAhead :: forall a. m a -> m a
mp_lookAhead = I.lookAhead

-- mp_notFollowedBy :: forall a. m a -> m ()
mp_notFollowedBy = I.notFollowedBy

-- mp_eof :: m ()
mp_eof = I.eof

-- mp_token :: forall a. (Int -> SourcePos -> t -> SourcePos) -> (t -> Either [Message] a) -> m a
mp_token = I.token

-- mp_tokens :: Eq t => (Int -> SourcePos -> [t] -> SourcePos) -> (t -> t -> Bool) -> [t] -> m [t]
mp_tokens = I.tokens

-- mp_getParserState :: m (State s)
mp_getParserState = I.getParserState

-- mp_updateParserState :: (State s -> State s) -> m ()
mp_updateParserState = I.updateParserState

type MpParsec a = I.Parsec a

type MpParsecT a b c = I.ParsecT a b c

type MpState a = I.State a

-- constructor :: s -> SourcePos -> Int -> State
mp_mk'State =  I.State
pattern MpState a b c <-  I.State a b c

-- mp_fromFile :: FilePath -> IO s
mp_fromFile = I.fromFile

-- mp_uncons :: s -> Maybe (t, s)
mp_uncons = I.uncons
