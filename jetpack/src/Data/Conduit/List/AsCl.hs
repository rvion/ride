-- generated by rvion/jetpack-gen 
module AsCl where
import Data.Conduit.List

-- ($wa) doesn't seem to be exported
-- ($wa1) doesn't seem to be exported
-- ($wa2) doesn't seem to be exported

cl_catMaybes :: forall a (m :: * -> *). Monad m => Conduit (Maybe a) m a
cl_catMaybes =  T.catMaybes
-- (catMaybesC) doesn't seem to be exported

cl_concat :: forall (f :: * -> *) a (m :: * -> *).
  (Monad m, Foldable f) =>
  Conduit (f a) m a
cl_concat =  T.concat
-- (concatC) doesn't seem to be exported

cl_concatMap :: forall a b (m :: * -> *). Monad m => (a -> [b]) -> Conduit a m b
cl_concatMap =  T.concatMap

cl_concatMapAccum :: forall a accum b (m :: * -> *).
  Monad m =>
  (a -> accum -> (accum, [b])) -> accum -> Conduit a m b
cl_concatMapAccum =  T.concatMapAccum
-- (concatMapAccum1) doesn't seem to be exported
-- (concatMapAccumC) doesn't seem to be exported

cl_concatMapAccumM :: forall a accum (m :: * -> *) b.
  Monad m =>
  (a -> accum -> m (accum, [b])) -> accum -> Conduit a m b
cl_concatMapAccumM =  T.concatMapAccumM
-- (concatMapAccumMC) doesn't seem to be exported
-- (concatMapC) doesn't seem to be exported

cl_concatMapM :: forall a (m :: * -> *) b. Monad m => (a -> m [b]) -> Conduit a m b
cl_concatMapM =  T.concatMapM
-- (concatMapMC) doesn't seem to be exported

cl_consume :: forall a (m :: * -> *). Monad m => Consumer a m [a]
cl_consume =  T.consume
-- (consumeC) doesn't seem to be exported

cl_drop :: forall a (m :: * -> *). Monad m => Int -> Consumer a m ()
cl_drop =  T.drop

cl_enumFromTo :: forall a (m :: * -> *).
  (Enum a, Ord a, Monad m) =>
  a -> a -> Producer m a
cl_enumFromTo =  T.enumFromTo
-- (enumFromToC) doesn't seem to be exported

cl_filter :: forall a (m :: * -> *). Monad m => (a -> Bool) -> Conduit a m a
cl_filter =  T.filter
-- (filter1) doesn't seem to be exported
-- (filterC) doesn't seem to be exported
-- (filterFuseRight) doesn't seem to be exported

cl_fold :: forall b a (m :: * -> *).
  Monad m =>
  (b -> a -> b) -> b -> Consumer a m b
cl_fold =  T.fold

cl_foldM :: forall b a (m :: * -> *).
  Monad m =>
  (b -> a -> m b) -> b -> Consumer a m b
cl_foldM =  T.foldM

cl_foldMap :: forall a b (m :: * -> *).
  (Monad m, Monoid b) =>
  (a -> b) -> Consumer a m b
cl_foldMap =  T.foldMap

cl_foldMapM :: forall a (m :: * -> *) b.
  (Monad m, Monoid b) =>
  (a -> m b) -> Consumer a m b
cl_foldMapM =  T.foldMapM

cl_groupBy :: forall a (m :: * -> *).
  Monad m =>
  (a -> a -> Bool) -> Conduit a m [a]
cl_groupBy =  T.groupBy
-- (groupBy1) doesn't seem to be exported
-- (groupByC) doesn't seem to be exported

cl_groupOn1 :: forall a b (m :: * -> *).
  (Monad m, Eq b) =>
  (a -> b) -> Conduit a m (a, [a])
cl_groupOn1 =  T.groupOn1
-- (groupOn1C) doesn't seem to be exported
-- (groupOn2) doesn't seem to be exported

cl_head :: forall a (m :: * -> *). Monad m => Consumer a m (Maybe a)
cl_head =  T.head

cl_isolate :: forall a (m :: * -> *). Monad m => Int -> Conduit a m a
cl_isolate =  T.isolate
-- (isolate1) doesn't seem to be exported
-- (isolateC) doesn't seem to be exported

cl_iterM :: forall a (m :: * -> *). Monad m => (a -> m ()) -> Conduit a m a
cl_iterM =  T.iterM
-- (iterMC) doesn't seem to be exported

cl_iterate :: forall a (m :: * -> *). Monad m => (a -> a) -> a -> Producer m a
cl_iterate =  T.iterate

cl_map :: forall a b (m :: * -> *). Monad m => (a -> b) -> Conduit a m b
cl_map =  T.map

cl_mapAccum :: forall a s b (m :: * -> *).
  Monad m =>
  (a -> s -> (s, b)) -> s -> ConduitM a b m s
cl_mapAccum =  T.mapAccum
-- (mapAccumC) doesn't seem to be exported

cl_mapAccumM :: forall a s (m :: * -> *) b.
  Monad m =>
  (a -> s -> m (s, b)) -> s -> ConduitM a b m s
cl_mapAccumM =  T.mapAccumM
-- (mapAccumMC) doesn't seem to be exported
-- (mapC) doesn't seem to be exported

cl_mapFoldable :: forall a (f :: * -> *) b (m :: * -> *).
  (Monad m, Foldable f) =>
  (a -> f b) -> Conduit a m b
cl_mapFoldable =  T.mapFoldable
-- (mapFoldableC) doesn't seem to be exported

cl_mapFoldableM :: forall a (m :: * -> *) (f :: * -> *) b.
  (Monad m, Foldable f) =>
  (a -> m (f b)) -> Conduit a m b
cl_mapFoldableM =  T.mapFoldableM
-- (mapFoldableMC) doesn't seem to be exported

cl_mapM :: forall a (m :: * -> *) b. Monad m => (a -> m b) -> Conduit a m b
cl_mapM =  T.mapM
-- (mapMC) doesn't seem to be exported

cl_mapM_ :: forall a (m :: * -> *). Monad m => (a -> m ()) -> Consumer a m ()
cl_mapM_ =  T.mapM_
-- (mapM_C) doesn't seem to be exported

cl_mapMaybe :: forall a b (m :: * -> *).
  Monad m =>
  (a -> Maybe b) -> Conduit a m b
cl_mapMaybe =  T.mapMaybe
-- (mapMaybeC) doesn't seem to be exported

cl_mapMaybeM :: forall a (m :: * -> *) b.
  Monad m =>
  (a -> m (Maybe b)) -> Conduit a m b
cl_mapMaybeM =  T.mapMaybeM
-- (mapMaybeMC) doesn't seem to be exported

cl_peek :: forall a (m :: * -> *). Monad m => Consumer a m (Maybe a)
cl_peek =  T.peek
-- (peek1) doesn't seem to be exported

cl_replicate :: forall a (m :: * -> *). Monad m => Int -> a -> Producer m a
cl_replicate =  T.replicate
-- (replicateC) doesn't seem to be exported

cl_replicateM :: forall (m :: * -> *) a. Monad m => Int -> m a -> Producer m a
cl_replicateM =  T.replicateM
-- (replicateMC) doesn't seem to be exported

cl_scan :: forall a b (m :: * -> *).
  Monad m =>
  (a -> b -> b) -> b -> ConduitM a b m b
cl_scan =  T.scan

cl_scanM :: forall a b (m :: * -> *).
  Monad m =>
  (a -> b -> m b) -> b -> ConduitM a b m b
cl_scanM =  T.scanM

cl_scanl :: forall a s b (m :: * -> *).
  Monad m =>
  (a -> s -> (s, b)) -> s -> Conduit a m b
cl_scanl =  T.scanl
-- (scanl1) doesn't seem to be exported

cl_scanlM :: forall a s (m :: * -> *) b.
  Monad m =>
  (a -> s -> m (s, b)) -> s -> Conduit a m b
cl_scanlM =  T.scanlM

cl_sequence :: forall i (m :: * -> *) o.
  Monad m =>
  Consumer i m o -> Conduit i m o
cl_sequence =  T.sequence
-- (sequence1) doesn't seem to be exported

cl_sinkNull :: forall a (m :: * -> *). Monad m => Consumer a m ()
cl_sinkNull =  T.sinkNull
-- (sinkNullC) doesn't seem to be exported

cl_sourceList :: forall a (m :: * -> *). Monad m => [a] -> Producer m a
cl_sourceList =  T.sourceList

cl_sourceNull :: forall (m :: * -> *) a. Monad m => Producer m a
cl_sourceNull =  T.sourceNull
-- (sourceNullC) doesn't seem to be exported
-- (srcMapM_) doesn't seem to be exported
-- (srcSinkNull) doesn't seem to be exported

cl_take :: forall a (m :: * -> *). Monad m => Int -> Consumer a m [a]
cl_take =  T.take

cl_unfold :: forall b a (m :: * -> *).
  Monad m =>
  (b -> Maybe (a, b)) -> b -> Producer m a
cl_unfold =  T.unfold

cl_unfoldM :: forall b (m :: * -> *) a.
  Monad m =>
  (b -> m (Maybe (a, b))) -> b -> Producer m a
cl_unfoldM =  T.unfoldM
-- (unfoldMC) doesn't seem to be exported
