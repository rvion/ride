module Data.Aeson.Types.AsJs where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import qualified Data.Aeson.Types as I

-- js_genericParseJSON :: forall a. (Generic a, GFromJSON (Rep a)) => Options -> Value -> Parser a
js_genericParseJSON = I.genericParseJSON

-- js_genericToJSON :: forall a. (Generic a, GToJSON (Rep a)) => Options -> a -> Value
js_genericToJSON = I.genericToJSON

-- (.!=) :: forall a. Parser (Maybe a) -> a -> Parser a
(.!=) = (I..!=)

-- (.:) :: forall a. FromJSON a => Object -> Text -> Parser a
(.:) = (I..:)

-- (.:?) :: forall a. FromJSON a => Object -> Text -> Parser (Maybe a)
(.:?) = (I..:?)

-- (.=) :: forall a. ToJSON a => Text -> a -> Pair
(.=) = (I..=)

-- js_fromJSON :: forall a. FromJSON a => Value -> Result a
js_fromJSON = I.fromJSON

-- js_typeMismatch :: forall a. String -> Value -> Parser a
js_typeMismatch = I.typeMismatch

-- js_withArray :: forall a. String -> (Array -> Parser a) -> Value -> Parser a
js_withArray = I.withArray

-- js_withBool :: forall a. String -> (Bool -> Parser a) -> Value -> Parser a
js_withBool = I.withBool

-- js_withObject :: forall a. String -> (Object -> Parser a) -> Value -> Parser a
js_withObject = I.withObject

-- js_withScientific :: forall a. String -> (Scientific -> Parser a) -> Value -> Parser a
js_withScientific = I.withScientific

-- js_withText :: forall a. String -> (Text -> Parser a) -> Value -> Parser a
js_withText = I.withText

-- js_camelTo :: Char -> String -> String
js_camelTo = I.camelTo

-- js_defaultOptions :: Options
js_defaultOptions = I.defaultOptions

-- js_defaultTaggedObject :: SumEncoding
js_defaultTaggedObject = I.defaultTaggedObject

-- js_emptyArray :: Value
js_emptyArray = I.emptyArray

-- js_emptyObject :: Value
js_emptyObject = I.emptyObject

-- js_modifyFailure :: forall a. (String -> String) -> Parser a -> Parser a
js_modifyFailure = I.modifyFailure

-- js_object :: [Pair] -> Value
js_object = I.object

-- js_parse :: forall a b. (a -> Parser b) -> a -> Result b
js_parse = I.parse

-- js_parseEither :: forall a b. (a -> Parser b) -> a -> Either String b
js_parseEither = I.parseEither

-- js_parseMaybe :: forall a b. (a -> Parser b) -> a -> Maybe b
js_parseMaybe = I.parseMaybe

-- js_parseJSON :: Value -> Parser a
js_parseJSON = I.parseJSON

-- js_gParseJSON :: forall a. Options -> Value -> Parser (f a)
js_gParseJSON = I.gParseJSON

-- js_gToJSON :: forall a. Options -> f a -> Value
js_gToJSON = I.gToJSON

-- js_toJSON :: a -> Value
js_toJSON = I.toJSON

type JsArray  = I.Array
type JsDotNetTime  = I.DotNetTime
type JsObject  = I.Object
type JsOptions  = I.Options
type JsPair  = I.Pair
type JsParser a = I.Parser a
type JsResult a = I.Result a
type JsSumEncoding  = I.SumEncoding
type JsValue  = I.Value
