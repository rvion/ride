-- generated by rvion/jetpack-gen 
module AsLbs where
import Data.ByteString.Lazy.Char8

-- ($wfirst) doesn't seem to be exported
-- ($wfirst') doesn't seem to be exported
-- ($wfoldl1') doesn't seem to be exported
-- ($wloop) doesn't seem to be exported
-- ($wloop0) doesn't seem to be exported
-- ($wmapAccumL) doesn't seem to be exported
-- ($wmapAccumR) doesn't seem to be exported

lbs_all :: (Char -> Bool) -> ByteString -> Bool
lbs_all =  T.all

lbs_any :: (Char -> Bool) -> ByteString -> Bool
lbs_any =  T.any

lbs_appendFile :: FilePath -> ByteString -> IO ()
lbs_appendFile =  T.appendFile
-- (appendFile1) doesn't seem to be exported

lbs_break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
lbs_break =  T.break

lbs_concatMap :: (Char -> ByteString) -> ByteString -> ByteString
lbs_concatMap =  T.concatMap

lbs_cons :: Char -> ByteString -> ByteString
lbs_cons =  T.cons

lbs_cons' :: Char -> ByteString -> ByteString
lbs_cons' =  T.cons'

lbs_count :: Char -> ByteString -> Int64
lbs_count =  T.count

lbs_dropWhile :: (Char -> Bool) -> ByteString -> ByteString
lbs_dropWhile =  T.dropWhile

lbs_elem :: Char -> ByteString -> Bool
lbs_elem =  T.elem

lbs_elemIndex :: Char -> ByteString -> Maybe Int64
lbs_elemIndex =  T.elemIndex

lbs_elemIndices :: Char -> ByteString -> [Int64]
lbs_elemIndices =  T.elemIndices

lbs_filter :: (Char -> Bool) -> ByteString -> ByteString
lbs_filter =  T.filter

lbs_find :: (Char -> Bool) -> ByteString -> Maybe Char
lbs_find =  T.find

lbs_findIndex :: (Char -> Bool) -> ByteString -> Maybe Int64
lbs_findIndex =  T.findIndex

lbs_findIndices :: (Char -> Bool) -> ByteString -> [Int64]
lbs_findIndices =  T.findIndices

lbs_foldl :: forall a. (a -> Char -> a) -> a -> ByteString -> a
lbs_foldl =  T.foldl

lbs_foldl' :: forall a. (a -> Char -> a) -> a -> ByteString -> a
lbs_foldl' =  T.foldl'

lbs_foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
lbs_foldl1 =  T.foldl1

lbs_foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
lbs_foldl1' =  T.foldl1'

lbs_foldr :: forall a. (Char -> a -> a) -> a -> ByteString -> a
lbs_foldr =  T.foldr

lbs_foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
lbs_foldr1 =  T.foldr1

lbs_groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
lbs_groupBy =  T.groupBy

lbs_hPutStrLn :: Handle -> ByteString -> IO ()
lbs_hPutStrLn =  T.hPutStrLn
-- (hPutStrLn1) doesn't seem to be exported
-- (hPutStrLn2) doesn't seem to be exported
-- (hPutStrLn3) doesn't seem to be exported

lbs_head :: ByteString -> Char
lbs_head =  T.head

lbs_index :: ByteString -> Int64 -> Char
lbs_index =  T.index

lbs_intersperse :: Char -> ByteString -> ByteString
lbs_intersperse =  T.intersperse

lbs_iterate :: (Char -> Char) -> Char -> ByteString
lbs_iterate =  T.iterate

lbs_last :: ByteString -> Char
lbs_last =  T.last

lbs_lines :: ByteString -> [ByteString]
lbs_lines =  T.lines
-- (lines_loop0) doesn't seem to be exported

lbs_map :: (Char -> Char) -> ByteString -> ByteString
lbs_map =  T.map

lbs_mapAccumL :: forall acc.
  (acc -> Char -> (acc, Char))
  -> acc -> ByteString -> (acc, ByteString)
lbs_mapAccumL =  T.mapAccumL

lbs_mapAccumR :: forall acc.
  (acc -> Char -> (acc, Char))
  -> acc -> ByteString -> (acc, ByteString)
lbs_mapAccumR =  T.mapAccumR

lbs_maximum :: ByteString -> Char
lbs_maximum =  T.maximum

lbs_minimum :: ByteString -> Char
lbs_minimum =  T.minimum

lbs_notElem :: Char -> ByteString -> Bool
lbs_notElem =  T.notElem

lbs_pack :: [Char] -> ByteString
lbs_pack =  T.pack

lbs_putStrLn :: ByteString -> IO ()
lbs_putStrLn =  T.putStrLn
-- (putStrLn1) doesn't seem to be exported

lbs_readFile :: FilePath -> IO ByteString
lbs_readFile =  T.readFile
-- (readFile1) doesn't seem to be exported

lbs_readInt :: ByteString -> Maybe (Int, ByteString)
lbs_readInt =  T.readInt

lbs_readInteger :: ByteString -> Maybe (Integer, ByteString)
lbs_readInteger =  T.readInteger

lbs_repeat :: Char -> ByteString
lbs_repeat =  T.repeat

lbs_replicate :: Int64 -> Char -> ByteString
lbs_replicate =  T.replicate

lbs_scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
lbs_scanl =  T.scanl

lbs_singleton :: Char -> ByteString
lbs_singleton =  T.singleton

lbs_snoc :: ByteString -> Char -> ByteString
lbs_snoc =  T.snoc

lbs_span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
lbs_span =  T.span

lbs_split :: Char -> ByteString -> [ByteString]
lbs_split =  T.split

lbs_splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
lbs_splitWith =  T.splitWith

lbs_takeWhile :: (Char -> Bool) -> ByteString -> ByteString
lbs_takeWhile =  T.takeWhile

lbs_uncons :: ByteString -> Maybe (Char, ByteString)
lbs_uncons =  T.uncons

lbs_unfoldr :: forall a. (a -> Maybe (Char, a)) -> a -> ByteString
lbs_unfoldr =  T.unfoldr

lbs_unlines :: [ByteString] -> ByteString
lbs_unlines =  T.unlines
-- (unlines1) doesn't seem to be exported
-- (unlines_go1) doesn't seem to be exported
-- (unlines_nl) doesn't seem to be exported

lbs_unpack :: ByteString -> [Char]
lbs_unpack =  T.unpack

lbs_unsnoc :: ByteString -> Maybe (ByteString, Char)
lbs_unsnoc =  T.unsnoc

lbs_unwords :: [ByteString] -> ByteString
lbs_unwords =  T.unwords

lbs_words :: ByteString -> [ByteString]
lbs_words =  T.words

lbs_writeFile :: FilePath -> ByteString -> IO ()
lbs_writeFile =  T.writeFile
-- (writeFile1) doesn't seem to be exported

lbs_zip :: ByteString -> ByteString -> [(Char, Char)]
lbs_zip =  T.zip

lbs_zipWith :: forall a. (Char -> Char -> a) -> ByteString -> ByteString -> [a]
lbs_zipWith =  T.zipWith
-- (zip_$szip) doesn't seem to be exported
