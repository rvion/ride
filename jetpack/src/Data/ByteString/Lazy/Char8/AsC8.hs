module Data.ByteString.Lazy.Char8.AsC8 where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import qualified Data.ByteString.Lazy.Char8 as I


-- c8_append :: ByteString -> ByteString -> ByteString
c8_append = I.append

-- c8_concat :: [ByteString] -> ByteString
c8_concat = I.concat

-- c8_copy :: ByteString -> ByteString
c8_copy = I.copy

-- c8_cycle :: ByteString -> ByteString
c8_cycle = I.cycle

-- c8_drop :: Int64 -> ByteString -> ByteString
c8_drop = I.drop

-- c8_empty :: ByteString
c8_empty = I.empty

-- c8_fromChunks :: [ByteString] -> ByteString
c8_fromChunks = I.fromChunks

-- c8_fromStrict :: ByteString -> ByteString
c8_fromStrict = I.fromStrict

-- c8_getContents :: IO ByteString
c8_getContents = I.getContents

-- c8_group :: ByteString -> [ByteString]
c8_group = I.group

-- c8_hGet :: Handle -> Int -> IO ByteString
c8_hGet = I.hGet

-- c8_hGetContents :: Handle -> IO ByteString
c8_hGetContents = I.hGetContents

-- c8_hGetNonBlocking :: Handle -> Int -> IO ByteString
c8_hGetNonBlocking = I.hGetNonBlocking

-- c8_hPut :: Handle -> ByteString -> IO ()
c8_hPut = I.hPut

-- c8_hPutNonBlocking :: Handle -> ByteString -> IO ByteString
c8_hPutNonBlocking = I.hPutNonBlocking

-- c8_hPutStr :: Handle -> ByteString -> IO ()
c8_hPutStr = I.hPutStr

-- c8_init :: ByteString -> ByteString
c8_init = I.init

-- c8_inits :: ByteString -> [ByteString]
c8_inits = I.inits

-- c8_interact :: (ByteString -> ByteString) -> IO ()
c8_interact = I.interact

-- c8_intercalate :: ByteString -> [ByteString] -> ByteString
c8_intercalate = I.intercalate

-- c8_isPrefixOf :: ByteString -> ByteString -> Bool
c8_isPrefixOf = I.isPrefixOf

-- c8_isSuffixOf :: ByteString -> ByteString -> Bool
c8_isSuffixOf = I.isSuffixOf

-- c8_length :: ByteString -> Int64
c8_length = I.length

-- c8_null :: ByteString -> Bool
c8_null = I.null

-- c8_putStr :: ByteString -> IO ()
c8_putStr = I.putStr

-- c8_reverse :: ByteString -> ByteString
c8_reverse = I.reverse

-- c8_splitAt :: Int64 -> ByteString -> (ByteString, ByteString)
c8_splitAt = I.splitAt

-- c8_tail :: ByteString -> ByteString
c8_tail = I.tail

-- c8_tails :: ByteString -> [ByteString]
c8_tails = I.tails

-- c8_take :: Int64 -> ByteString -> ByteString
c8_take = I.take

-- c8_toChunks :: ByteString -> [ByteString]
c8_toChunks = I.toChunks

-- c8_toStrict :: ByteString -> ByteString
c8_toStrict = I.toStrict

-- c8_transpose :: [ByteString] -> [ByteString]
c8_transpose = I.transpose

-- c8_all :: (Char -> Bool) -> ByteString -> Bool
c8_all = I.all

-- c8_any :: (Char -> Bool) -> ByteString -> Bool
c8_any = I.any

-- c8_appendFile :: FilePath -> ByteString -> IO ()
c8_appendFile = I.appendFile

-- c8_break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
c8_break = I.break

-- c8_concatMap :: (Char -> ByteString) -> ByteString -> ByteString
c8_concatMap = I.concatMap

-- c8_cons :: Char -> ByteString -> ByteString
c8_cons = I.cons

-- c8_cons' :: Char -> ByteString -> ByteString
c8_cons' = I.cons'

-- c8_count :: Char -> ByteString -> Int64
c8_count = I.count

-- c8_dropWhile :: (Char -> Bool) -> ByteString -> ByteString
c8_dropWhile = I.dropWhile

-- c8_elem :: Char -> ByteString -> Bool
c8_elem = I.elem

-- c8_elemIndex :: Char -> ByteString -> Maybe Int64
c8_elemIndex = I.elemIndex

-- c8_elemIndices :: Char -> ByteString -> [Int64]
c8_elemIndices = I.elemIndices

-- c8_filter :: (Char -> Bool) -> ByteString -> ByteString
c8_filter = I.filter

-- c8_find :: (Char -> Bool) -> ByteString -> Maybe Char
c8_find = I.find

-- c8_findIndex :: (Char -> Bool) -> ByteString -> Maybe Int64
c8_findIndex = I.findIndex

-- c8_findIndices :: (Char -> Bool) -> ByteString -> [Int64]
c8_findIndices = I.findIndices

-- c8_foldl :: forall a. (a -> Char -> a) -> a -> ByteString -> a
c8_foldl = I.foldl

-- c8_foldl' :: forall a. (a -> Char -> a) -> a -> ByteString -> a
c8_foldl' = I.foldl'

-- c8_foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
c8_foldl1 = I.foldl1

-- c8_foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
c8_foldl1' = I.foldl1'

-- c8_foldr :: forall a. (Char -> a -> a) -> a -> ByteString -> a
c8_foldr = I.foldr

-- c8_foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
c8_foldr1 = I.foldr1

-- c8_groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
c8_groupBy = I.groupBy

-- c8_hPutStrLn :: Handle -> ByteString -> IO ()
c8_hPutStrLn = I.hPutStrLn

-- c8_head :: ByteString -> Char
c8_head = I.head

-- c8_index :: ByteString -> Int64 -> Char
c8_index = I.index

-- c8_intersperse :: Char -> ByteString -> ByteString
c8_intersperse = I.intersperse

-- c8_iterate :: (Char -> Char) -> Char -> ByteString
c8_iterate = I.iterate

-- c8_last :: ByteString -> Char
c8_last = I.last

-- c8_lines :: ByteString -> [ByteString]
c8_lines = I.lines

-- c8_map :: (Char -> Char) -> ByteString -> ByteString
c8_map = I.map

-- c8_mapAccumL :: forall acc. (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
c8_mapAccumL = I.mapAccumL

-- c8_mapAccumR :: forall acc. (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
c8_mapAccumR = I.mapAccumR

-- c8_maximum :: ByteString -> Char
c8_maximum = I.maximum

-- c8_minimum :: ByteString -> Char
c8_minimum = I.minimum

-- c8_notElem :: Char -> ByteString -> Bool
c8_notElem = I.notElem

-- c8_pack :: [Char] -> ByteString
c8_pack = I.pack

-- c8_putStrLn :: ByteString -> IO ()
c8_putStrLn = I.putStrLn

-- c8_readFile :: FilePath -> IO ByteString
c8_readFile = I.readFile

-- c8_readInt :: ByteString -> Maybe (Int, ByteString)
c8_readInt = I.readInt

-- c8_readInteger :: ByteString -> Maybe (Integer, ByteString)
c8_readInteger = I.readInteger

-- c8_repeat :: Char -> ByteString
c8_repeat = I.repeat

-- c8_replicate :: Int64 -> Char -> ByteString
c8_replicate = I.replicate

-- c8_scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
c8_scanl = I.scanl

-- c8_singleton :: Char -> ByteString
c8_singleton = I.singleton

-- c8_snoc :: ByteString -> Char -> ByteString
c8_snoc = I.snoc

-- c8_span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
c8_span = I.span

-- c8_split :: Char -> ByteString -> [ByteString]
c8_split = I.split

-- c8_splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
c8_splitWith = I.splitWith

-- c8_takeWhile :: (Char -> Bool) -> ByteString -> ByteString
c8_takeWhile = I.takeWhile

-- c8_uncons :: ByteString -> Maybe (Char, ByteString)
c8_uncons = I.uncons

-- c8_unfoldr :: forall a. (a -> Maybe (Char, a)) -> a -> ByteString
c8_unfoldr = I.unfoldr

-- c8_unlines :: [ByteString] -> ByteString
c8_unlines = I.unlines

-- c8_unpack :: ByteString -> [Char]
c8_unpack = I.unpack

-- c8_unsnoc :: ByteString -> Maybe (ByteString, Char)
c8_unsnoc = I.unsnoc

-- c8_unwords :: [ByteString] -> ByteString
c8_unwords = I.unwords

-- c8_words :: ByteString -> [ByteString]
c8_words = I.words

-- c8_writeFile :: FilePath -> ByteString -> IO ()
c8_writeFile = I.writeFile

-- c8_zip :: ByteString -> ByteString -> [(Char, Char)]
c8_zip = I.zip

-- c8_zipWith :: forall a. (Char -> Char -> a) -> ByteString -> ByteString -> [a]
c8_zipWith = I.zipWith

type C8ByteString  = I.ByteString
