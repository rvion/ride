module Data.ByteString.AsBs where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import qualified Data.ByteString as I

-- bs_all :: (Word8 -> Bool) -> ByteString -> Bool
bs_all = I.all

-- bs_any :: (Word8 -> Bool) -> ByteString -> Bool
bs_any = I.any

-- bs_append :: ByteString -> ByteString -> ByteString
bs_append = I.append

-- bs_appendFile :: FilePath -> ByteString -> IO ()
bs_appendFile = I.appendFile

-- bs_break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
bs_break = I.break

-- bs_breakEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
bs_breakEnd = I.breakEnd

-- bs_breakSubstring :: ByteString -> ByteString -> (ByteString, ByteString)
bs_breakSubstring = I.breakSubstring

-- bs_concat :: [ByteString] -> ByteString
bs_concat = I.concat

-- bs_concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
bs_concatMap = I.concatMap

-- bs_cons :: Word8 -> ByteString -> ByteString
bs_cons = I.cons

-- bs_copy :: ByteString -> ByteString
bs_copy = I.copy

-- bs_count :: Word8 -> ByteString -> Int
bs_count = I.count

-- bs_drop :: Int -> ByteString -> ByteString
bs_drop = I.drop

-- bs_dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
bs_dropWhile = I.dropWhile

-- bs_elem :: Word8 -> ByteString -> Bool
bs_elem = I.elem

-- bs_elemIndex :: Word8 -> ByteString -> Maybe Int
bs_elemIndex = I.elemIndex

-- bs_elemIndexEnd :: Word8 -> ByteString -> Maybe Int
bs_elemIndexEnd = I.elemIndexEnd

-- bs_elemIndices :: Word8 -> ByteString -> [Int]
bs_elemIndices = I.elemIndices

-- bs_empty :: ByteString
bs_empty = I.empty

-- bs_filter :: (Word8 -> Bool) -> ByteString -> ByteString
bs_filter = I.filter

-- bs_find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
bs_find = I.find

-- bs_findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int
bs_findIndex = I.findIndex

-- bs_findIndices :: (Word8 -> Bool) -> ByteString -> [Int]
bs_findIndices = I.findIndices

-- bs_foldl :: forall a. (a -> Word8 -> a) -> a -> ByteString -> a
bs_foldl = I.foldl

-- bs_foldl' :: forall a. (a -> Word8 -> a) -> a -> ByteString -> a
bs_foldl' = I.foldl'

-- bs_foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
bs_foldl1 = I.foldl1

-- bs_foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
bs_foldl1' = I.foldl1'

-- bs_foldr :: forall a. (Word8 -> a -> a) -> a -> ByteString -> a
bs_foldr = I.foldr

-- bs_foldr' :: forall a. (Word8 -> a -> a) -> a -> ByteString -> a
bs_foldr' = I.foldr'

-- bs_foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
bs_foldr1 = I.foldr1

-- bs_foldr1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
bs_foldr1' = I.foldr1'

-- bs_getContents :: IO ByteString
bs_getContents = I.getContents

-- bs_getLine :: IO ByteString
bs_getLine = I.getLine

-- bs_group :: ByteString -> [ByteString]
bs_group = I.group

-- bs_groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
bs_groupBy = I.groupBy

-- bs_hGet :: Handle -> Int -> IO ByteString
bs_hGet = I.hGet

-- bs_hGetContents :: Handle -> IO ByteString
bs_hGetContents = I.hGetContents

-- bs_hGetLine :: Handle -> IO ByteString
bs_hGetLine = I.hGetLine

-- bs_hGetNonBlocking :: Handle -> Int -> IO ByteString
bs_hGetNonBlocking = I.hGetNonBlocking

-- bs_hGetSome :: Handle -> Int -> IO ByteString
bs_hGetSome = I.hGetSome

-- bs_hPut :: Handle -> ByteString -> IO ()
bs_hPut = I.hPut

-- bs_hPutNonBlocking :: Handle -> ByteString -> IO ByteString
bs_hPutNonBlocking = I.hPutNonBlocking

-- bs_hPutStr :: Handle -> ByteString -> IO ()
bs_hPutStr = I.hPutStr

-- bs_head :: ByteString -> Word8
bs_head = I.head

-- bs_index :: ByteString -> Int -> Word8
bs_index = I.index

-- bs_init :: ByteString -> ByteString
bs_init = I.init

-- bs_inits :: ByteString -> [ByteString]
bs_inits = I.inits

-- bs_interact :: (ByteString -> ByteString) -> IO ()
bs_interact = I.interact

-- bs_intercalate :: ByteString -> [ByteString] -> ByteString
bs_intercalate = I.intercalate

-- bs_intersperse :: Word8 -> ByteString -> ByteString
bs_intersperse = I.intersperse

-- bs_isInfixOf :: ByteString -> ByteString -> Bool
bs_isInfixOf = I.isInfixOf

-- bs_isPrefixOf :: ByteString -> ByteString -> Bool
bs_isPrefixOf = I.isPrefixOf

-- bs_isSuffixOf :: ByteString -> ByteString -> Bool
bs_isSuffixOf = I.isSuffixOf

-- bs_last :: ByteString -> Word8
bs_last = I.last

-- bs_length :: ByteString -> Int
bs_length = I.length

-- bs_map :: (Word8 -> Word8) -> ByteString -> ByteString
bs_map = I.map

-- bs_mapAccumL :: forall acc. (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
bs_mapAccumL = I.mapAccumL

-- bs_mapAccumR :: forall acc. (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
bs_mapAccumR = I.mapAccumR

-- bs_maximum :: ByteString -> Word8
bs_maximum = I.maximum

-- bs_minimum :: ByteString -> Word8
bs_minimum = I.minimum

-- bs_notElem :: Word8 -> ByteString -> Bool
bs_notElem = I.notElem

-- bs_null :: ByteString -> Bool
bs_null = I.null

-- bs_pack :: [Word8] -> ByteString
bs_pack = I.pack

-- bs_packCString :: CString -> IO ByteString
bs_packCString = I.packCString

-- bs_packCStringLen :: CStringLen -> IO ByteString
bs_packCStringLen = I.packCStringLen

-- bs_partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
bs_partition = I.partition

-- bs_putStr :: ByteString -> IO ()
bs_putStr = I.putStr

-- bs_readFile :: FilePath -> IO ByteString
bs_readFile = I.readFile

-- bs_replicate :: Int -> Word8 -> ByteString
bs_replicate = I.replicate

-- bs_reverse :: ByteString -> ByteString
bs_reverse = I.reverse

-- bs_scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
bs_scanl = I.scanl

-- bs_scanl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
bs_scanl1 = I.scanl1

-- bs_scanr :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
bs_scanr = I.scanr

-- bs_scanr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
bs_scanr1 = I.scanr1

-- bs_singleton :: Word8 -> ByteString
bs_singleton = I.singleton

-- bs_snoc :: ByteString -> Word8 -> ByteString
bs_snoc = I.snoc

-- bs_sort :: ByteString -> ByteString
bs_sort = I.sort

-- bs_span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
bs_span = I.span

-- bs_spanEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
bs_spanEnd = I.spanEnd

-- bs_split :: Word8 -> ByteString -> [ByteString]
bs_split = I.split

-- bs_splitAt :: Int -> ByteString -> (ByteString, ByteString)
bs_splitAt = I.splitAt

-- bs_splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
bs_splitWith = I.splitWith

-- bs_tail :: ByteString -> ByteString
bs_tail = I.tail

-- bs_tails :: ByteString -> [ByteString]
bs_tails = I.tails

-- bs_take :: Int -> ByteString -> ByteString
bs_take = I.take

-- bs_takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
bs_takeWhile = I.takeWhile

-- bs_transpose :: [ByteString] -> [ByteString]
bs_transpose = I.transpose

-- bs_uncons :: ByteString -> Maybe (Word8, ByteString)
bs_uncons = I.uncons

-- bs_unfoldr :: forall a. (a -> Maybe (Word8, a)) -> a -> ByteString
bs_unfoldr = I.unfoldr

-- bs_unfoldrN :: forall a. Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
bs_unfoldrN = I.unfoldrN

-- bs_unpack :: ByteString -> [Word8]
bs_unpack = I.unpack

-- bs_unsnoc :: ByteString -> Maybe (ByteString, Word8)
bs_unsnoc = I.unsnoc

-- bs_unzip :: [(Word8, Word8)] -> (ByteString, ByteString)
bs_unzip = I.unzip

-- bs_useAsCString :: forall a. ByteString -> (CString -> IO a) -> IO a
bs_useAsCString = I.useAsCString

-- bs_useAsCStringLen :: forall a. ByteString -> (CStringLen -> IO a) -> IO a
bs_useAsCStringLen = I.useAsCStringLen

-- bs_writeFile :: FilePath -> ByteString -> IO ()
bs_writeFile = I.writeFile

-- bs_zip :: ByteString -> ByteString -> [(Word8, Word8)]
bs_zip = I.zip

-- bs_zipWith :: forall a. (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
bs_zipWith = I.zipWith

type BsByteString  = I.ByteString
