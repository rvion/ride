 -- generated by rvion/jetpack-gen 
module AsBs.hs where
import Data.ByteString.Char8

-- ($wa) doesn't seem to be exported
-- ($wa1) doesn't seem to be exported
-- ($wa2) doesn't seem to be exported
-- ($wfindIndices) doesn't seem to be exported
-- ($wfirst) doesn't seem to be exported
-- ($wgroupBy) doesn't seem to be exported
-- ($wlines) doesn't seem to be exported
-- ($wloop) doesn't seem to be exported
-- ($wmapAccumL) doesn't seem to be exported
-- ($wmapAccumR) doesn't seem to be exported
-- ($wreadInt) doesn't seem to be exported
-- ($wreadInteger) doesn't seem to be exported
-- ($wscanl) doesn't seem to be exported
-- ($wscanl1) doesn't seem to be exported
-- ($wscanr) doesn't seem to be exported
-- ($wscanr1) doesn't seem to be exported
-- ($wzip) doesn't seem to be exported
-- ($wzipWith) doesn't seem to be exported

bs_all :: (Char -> Bool) -> ByteString -> Bool
bs_all =  T.all

bs_any :: (Char -> Bool) -> ByteString -> Bool
bs_any =  T.any

bs_appendFile :: FilePath -> ByteString -> IO ()
bs_appendFile =  T.appendFile
-- (appendFile1) doesn't seem to be exported

bs_break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
bs_break =  T.break
-- (break1) doesn't seem to be exported
-- (breakChar) doesn't seem to be exported

bs_breakEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
bs_breakEnd =  T.breakEnd
-- (breakSpace) doesn't seem to be exported

bs_concatMap :: (Char -> ByteString) -> ByteString -> ByteString
bs_concatMap =  T.concatMap

bs_cons :: Char -> ByteString -> ByteString
bs_cons =  T.cons

bs_count :: Char -> ByteString -> Int
bs_count =  T.count
-- (dropSpace) doesn't seem to be exported

bs_dropWhile :: (Char -> Bool) -> ByteString -> ByteString
bs_dropWhile =  T.dropWhile
-- (dropWhile1) doesn't seem to be exported

bs_elem :: Char -> ByteString -> Bool
bs_elem =  T.elem

bs_elemIndex :: Char -> ByteString -> Maybe Int
bs_elemIndex =  T.elemIndex

bs_elemIndexEnd :: Char -> ByteString -> Maybe Int
bs_elemIndexEnd =  T.elemIndexEnd

bs_elemIndices :: Char -> ByteString -> [Int]
bs_elemIndices =  T.elemIndices

bs_filter :: (Char -> Bool) -> ByteString -> ByteString
bs_filter =  T.filter

bs_find :: (Char -> Bool) -> ByteString -> Maybe Char
bs_find =  T.find

bs_findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
bs_findIndex =  T.findIndex

bs_findIndices :: (Char -> Bool) -> ByteString -> [Int]
bs_findIndices =  T.findIndices
-- (firstnonspace) doesn't seem to be exported
-- (firstspace) doesn't seem to be exported

bs_foldl :: forall a. (a -> Char -> a) -> a -> ByteString -> a
bs_foldl =  T.foldl

bs_foldl' :: forall a. (a -> Char -> a) -> a -> ByteString -> a
bs_foldl' =  T.foldl'

bs_foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
bs_foldl1 =  T.foldl1

bs_foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
bs_foldl1' =  T.foldl1'

bs_foldr :: forall a. (Char -> a -> a) -> a -> ByteString -> a
bs_foldr =  T.foldr

bs_foldr' :: forall a. (Char -> a -> a) -> a -> ByteString -> a
bs_foldr' =  T.foldr'

bs_foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
bs_foldr1 =  T.foldr1

bs_foldr1' :: (Char -> Char -> Char) -> ByteString -> Char
bs_foldr1' =  T.foldr1'

bs_groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
bs_groupBy =  T.groupBy

bs_hPutStrLn :: Handle -> ByteString -> IO ()
bs_hPutStrLn =  T.hPutStrLn
-- (hPutStrLn1) doesn't seem to be exported
-- (hPutStrLn2) doesn't seem to be exported
-- (hPutStrLn3) doesn't seem to be exported

bs_head :: ByteString -> Char
bs_head =  T.head

bs_index :: ByteString -> Int -> Char
bs_index =  T.index

bs_intersperse :: Char -> ByteString -> ByteString
bs_intersperse =  T.intersperse

bs_last :: ByteString -> Char
bs_last =  T.last

bs_lines :: ByteString -> [ByteString]
bs_lines =  T.lines

bs_map :: (Char -> Char) -> ByteString -> ByteString
bs_map =  T.map

bs_mapAccumL :: forall acc.
  (acc -> Char -> (acc, Char))
  -> acc -> ByteString -> (acc, ByteString)
bs_mapAccumL =  T.mapAccumL

bs_mapAccumR :: forall acc.
  (acc -> Char -> (acc, Char))
  -> acc -> ByteString -> (acc, ByteString)
bs_mapAccumR =  T.mapAccumR

bs_maximum :: ByteString -> Char
bs_maximum =  T.maximum

bs_minimum :: ByteString -> Char
bs_minimum =  T.minimum

bs_notElem :: Char -> ByteString -> Bool
bs_notElem =  T.notElem

bs_pack :: String -> ByteString
bs_pack =  T.pack

bs_putStrLn :: ByteString -> IO ()
bs_putStrLn =  T.putStrLn
-- (putStrLn1) doesn't seem to be exported

bs_readFile :: FilePath -> IO ByteString
bs_readFile =  T.readFile
-- (readFile1) doesn't seem to be exported
-- (readFile2) doesn't seem to be exported

bs_readInt :: ByteString -> Maybe (Int, ByteString)
bs_readInt =  T.readInt
-- (readInt_$s$wloop) doesn't seem to be exported
-- (readInt_$s$wloop1) doesn't seem to be exported

bs_readInteger :: ByteString -> Maybe (Integer, ByteString)
bs_readInteger =  T.readInteger

bs_replicate :: Int -> Char -> ByteString
bs_replicate =  T.replicate

bs_scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
bs_scanl =  T.scanl

bs_scanl1 :: (Char -> Char -> Char) -> ByteString -> ByteString
bs_scanl1 =  T.scanl1

bs_scanr :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
bs_scanr =  T.scanr

bs_scanr1 :: (Char -> Char -> Char) -> ByteString -> ByteString
bs_scanr1 =  T.scanr1

bs_singleton :: Char -> ByteString
bs_singleton =  T.singleton

bs_snoc :: ByteString -> Char -> ByteString
bs_snoc =  T.snoc

bs_span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
bs_span =  T.span

bs_spanEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
bs_spanEnd =  T.spanEnd

bs_split :: Char -> ByteString -> [ByteString]
bs_split =  T.split

bs_splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
bs_splitWith =  T.splitWith

bs_takeWhile :: (Char -> Bool) -> ByteString -> ByteString
bs_takeWhile =  T.takeWhile

bs_uncons :: ByteString -> Maybe (Char, ByteString)
bs_uncons =  T.uncons

bs_unfoldr :: forall a. (a -> Maybe (Char, a)) -> a -> ByteString
bs_unfoldr =  T.unfoldr
-- (unfoldr1) doesn't seem to be exported

bs_unfoldrN :: forall a.
  Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
bs_unfoldrN =  T.unfoldrN

bs_unlines :: [ByteString] -> ByteString
bs_unlines =  T.unlines
-- (unlines1) doesn't seem to be exported
-- (unlines_nl) doesn't seem to be exported

bs_unpack :: ByteString -> [Char]
bs_unpack =  T.unpack

bs_unsnoc :: ByteString -> Maybe (ByteString, Char)
bs_unsnoc =  T.unsnoc

bs_unwords :: [ByteString] -> ByteString
bs_unwords =  T.unwords

bs_unzip :: [(Char, Char)] -> (ByteString, ByteString)
bs_unzip =  T.unzip

bs_words :: ByteString -> [ByteString]
bs_words =  T.words

bs_writeFile :: FilePath -> ByteString -> IO ()
bs_writeFile =  T.writeFile
-- (writeFile1) doesn't seem to be exported

bs_zip :: ByteString -> ByteString -> [(Char, Char)]
bs_zip =  T.zip

bs_zipWith :: forall a. (Char -> Char -> a) -> ByteString -> ByteString -> [a]
bs_zipWith =  T.zipWith
-- (zip_$s$wzip) doesn't seem to be exported
