module Data.Map.Strict.AsM where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import           Data.Map.Strict as I

-- (!) :: forall k a. Ord k => Map k a -> k -> a
(!) = (I.!)

-- (\\) :: forall k a b. Ord k => Map k a -> Map k b -> Map k a
(\\) = (I.\\)

-- m_assocs :: forall k a. Map k a -> [(k, a)]
m_assocs = I.assocs

-- m_delete :: forall k a. Ord k => k -> Map k a -> Map k a
m_delete = I.delete

-- m_deleteAt :: forall k a. Int -> Map k a -> Map k a
m_deleteAt = I.deleteAt

-- m_deleteFindMax :: forall k a. Map k a -> ((k, a), Map k a)
m_deleteFindMax = I.deleteFindMax

-- m_deleteFindMin :: forall k a. Map k a -> ((k, a), Map k a)
m_deleteFindMin = I.deleteFindMin

-- m_deleteMax :: forall k a. Map k a -> Map k a
m_deleteMax = I.deleteMax

-- m_deleteMin :: forall k a. Map k a -> Map k a
m_deleteMin = I.deleteMin

-- m_difference :: forall k a b. Ord k => Map k a -> Map k b -> Map k a
m_difference = I.difference

-- m_elemAt :: forall k a. Int -> Map k a -> (k, a)
m_elemAt = I.elemAt

-- m_elems :: forall k a. Map k a -> [a]
m_elems = I.elems

-- m_empty :: forall k a. Map k a
m_empty = I.empty

-- m_filter :: forall a k. (a -> Bool) -> Map k a -> Map k a
m_filter = I.filter

-- m_filterWithKey :: forall k a. (k -> a -> Bool) -> Map k a -> Map k a
m_filterWithKey = I.filterWithKey

-- m_findIndex :: forall k a. Ord k => k -> Map k a -> Int
m_findIndex = I.findIndex

-- m_findMax :: forall k a. Map k a -> (k, a)
m_findMax = I.findMax

-- m_findMin :: forall k a. Map k a -> (k, a)
m_findMin = I.findMin

-- m_foldMapWithKey :: forall k a m. Monoid m => (k -> a -> m) -> Map k a -> m
m_foldMapWithKey = I.foldMapWithKey

-- m_foldl :: forall a b k. (a -> b -> a) -> a -> Map k b -> a
m_foldl = I.foldl

-- m_foldl' :: forall a b k. (a -> b -> a) -> a -> Map k b -> a
m_foldl' = I.foldl'

-- m_foldlWithKey :: forall a k b. (a -> k -> b -> a) -> a -> Map k b -> a
m_foldlWithKey = I.foldlWithKey

-- m_foldlWithKey' :: forall a k b. (a -> k -> b -> a) -> a -> Map k b -> a
m_foldlWithKey' = I.foldlWithKey'

-- m_foldr :: forall a b k. (a -> b -> b) -> b -> Map k a -> b
m_foldr = I.foldr

-- m_foldr' :: forall a b k. (a -> b -> b) -> b -> Map k a -> b
m_foldr' = I.foldr'

-- m_foldrWithKey :: forall k a b. (k -> a -> b -> b) -> b -> Map k a -> b
m_foldrWithKey = I.foldrWithKey

-- m_foldrWithKey' :: forall k a b. (k -> a -> b -> b) -> b -> Map k a -> b
m_foldrWithKey' = I.foldrWithKey'

-- m_intersection :: forall k a b. Ord k => Map k a -> Map k b -> Map k a
m_intersection = I.intersection

-- m_isProperSubmapOf :: forall k a. (Ord k, Eq a) => Map k a -> Map k a -> Bool
m_isProperSubmapOf = I.isProperSubmapOf

-- m_isProperSubmapOfBy :: forall a b k. Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
m_isProperSubmapOfBy = I.isProperSubmapOfBy

-- m_isSubmapOf :: forall k a. (Ord k, Eq a) => Map k a -> Map k a -> Bool
m_isSubmapOf = I.isSubmapOf

-- m_isSubmapOfBy :: forall a b k. Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
m_isSubmapOfBy = I.isSubmapOfBy

-- m_keys :: forall k a. Map k a -> [k]
m_keys = I.keys

-- m_keysSet :: forall k a. Map k a -> Set k
m_keysSet = I.keysSet

-- m_lookup :: forall k a. Ord k => k -> Map k a -> Maybe a
m_lookup = I.lookup

-- m_lookupGE :: forall k v. Ord k => k -> Map k v -> Maybe (k, v)
m_lookupGE = I.lookupGE

-- m_lookupGT :: forall k v. Ord k => k -> Map k v -> Maybe (k, v)
m_lookupGT = I.lookupGT

-- m_lookupIndex :: forall k a. Ord k => k -> Map k a -> Maybe Int
m_lookupIndex = I.lookupIndex

-- m_lookupLE :: forall k v. Ord k => k -> Map k v -> Maybe (k, v)
m_lookupLE = I.lookupLE

-- m_lookupLT :: forall k v. Ord k => k -> Map k v -> Maybe (k, v)
m_lookupLT = I.lookupLT

-- m_mapKeys :: forall k1 k2 a. Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
m_mapKeys = I.mapKeys

-- m_mapKeysMonotonic :: forall k1 k2 a. (k1 -> k2) -> Map k1 a -> Map k2 a
m_mapKeysMonotonic = I.mapKeysMonotonic

-- m_maxView :: forall k a. Map k a -> Maybe (a, Map k a)
m_maxView = I.maxView

-- m_maxViewWithKey :: forall k a. Map k a -> Maybe ((k, a), Map k a)
m_maxViewWithKey = I.maxViewWithKey

-- m_member :: forall k a. Ord k => k -> Map k a -> Bool
m_member = I.member

-- m_minView :: forall k a. Map k a -> Maybe (a, Map k a)
m_minView = I.minView

-- m_minViewWithKey :: forall k a. Map k a -> Maybe ((k, a), Map k a)
m_minViewWithKey = I.minViewWithKey

-- m_notMember :: forall k a. Ord k => k -> Map k a -> Bool
m_notMember = I.notMember

-- m_null :: forall k a. Map k a -> Bool
m_null = I.null

-- m_partition :: forall a k. (a -> Bool) -> Map k a -> (Map k a, Map k a)
m_partition = I.partition

-- m_partitionWithKey :: forall k a. (k -> a -> Bool) -> Map k a -> (Map k a, Map k a)
m_partitionWithKey = I.partitionWithKey

-- m_showTree :: forall k a. (Show k, Show a) => Map k a -> String
m_showTree = I.showTree

-- m_showTreeWith :: forall k a. (k -> a -> String) -> Bool -> Bool -> Map k a -> String
m_showTreeWith = I.showTreeWith

-- m_size :: forall k a. Map k a -> Int
m_size = I.size

-- m_split :: forall k a. Ord k => k -> Map k a -> (Map k a, Map k a)
m_split = I.split

-- m_splitLookup :: forall k a. Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)
m_splitLookup = I.splitLookup

-- m_splitRoot :: forall k b. Map k b -> [Map k b]
m_splitRoot = I.splitRoot

-- m_toAscList :: forall k a. Map k a -> [(k, a)]
m_toAscList = I.toAscList

-- m_toDescList :: forall k a. Map k a -> [(k, a)]
m_toDescList = I.toDescList

-- m_toList :: forall k a. Map k a -> [(k, a)]
m_toList = I.toList

-- m_traverseWithKey :: forall k a (t :: * -> *) b. Applicative t => (k -> a -> t b) -> Map k a -> t (Map k b)
m_traverseWithKey = I.traverseWithKey

-- m_union :: forall k a. Ord k => Map k a -> Map k a -> Map k a
m_union = I.union

-- m_unions :: forall k a. Ord k => [Map k a] -> Map k a
m_unions = I.unions

-- m_valid :: forall k a. Ord k => Map k a -> Bool
m_valid = I.valid

-- m_adjust :: forall a k. Ord k => (a -> a) -> k -> Map k a -> Map k a
m_adjust = I.adjust

-- m_adjustWithKey :: forall k a. Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
m_adjustWithKey = I.adjustWithKey

-- m_alter :: forall a k. Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
m_alter = I.alter

-- m_differenceWith :: forall a b k. Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
m_differenceWith = I.differenceWith

-- m_differenceWithKey :: forall k a b. Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
m_differenceWithKey = I.differenceWithKey

-- m_findWithDefault :: forall a k. Ord k => a -> k -> Map k a -> a
m_findWithDefault = I.findWithDefault

-- m_fromAscList :: forall k a. Eq k => [(k, a)] -> Map k a
m_fromAscList = I.fromAscList

-- m_fromAscListWith :: forall a k. Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
m_fromAscListWith = I.fromAscListWith

-- m_fromAscListWithKey :: forall k a. Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
m_fromAscListWithKey = I.fromAscListWithKey

-- m_fromDistinctAscList :: forall k a. [(k, a)] -> Map k a
m_fromDistinctAscList = I.fromDistinctAscList

-- m_fromList :: forall k a. Ord k => [(k, a)] -> Map k a
m_fromList = I.fromList

-- m_fromListWith :: forall a k. Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
m_fromListWith = I.fromListWith

-- m_fromListWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
m_fromListWithKey = I.fromListWithKey

-- m_fromSet :: forall k a. (k -> a) -> Set k -> Map k a
m_fromSet = I.fromSet

-- m_insert :: forall k a. Ord k => k -> a -> Map k a -> Map k a
m_insert = I.insert

-- m_insertLookupWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
m_insertLookupWithKey = I.insertLookupWithKey

-- m_insertWith :: forall a k. Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
m_insertWith = I.insertWith

-- m_insertWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
m_insertWithKey = I.insertWithKey

-- m_intersectionWith :: forall a b c k. Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
m_intersectionWith = I.intersectionWith

-- m_intersectionWithKey :: forall k a b c. Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
m_intersectionWithKey = I.intersectionWithKey

-- m_map :: forall a b k. (a -> b) -> Map k a -> Map k b
m_map = I.map

-- m_mapAccum :: forall a b c k. (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
m_mapAccum = I.mapAccum

-- m_mapAccumRWithKey :: forall a k b c. (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
m_mapAccumRWithKey = I.mapAccumRWithKey

-- m_mapAccumWithKey :: forall a k b c. (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
m_mapAccumWithKey = I.mapAccumWithKey

-- m_mapEither :: forall a b c k. (a -> Either b c) -> Map k a -> (Map k b, Map k c)
m_mapEither = I.mapEither

-- m_mapEitherWithKey :: forall k a b c. (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)
m_mapEitherWithKey = I.mapEitherWithKey

-- m_mapKeysWith :: forall a k1 k2. Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
m_mapKeysWith = I.mapKeysWith

-- m_mapMaybe :: forall a b k. (a -> Maybe b) -> Map k a -> Map k b
m_mapMaybe = I.mapMaybe

-- m_mapMaybeWithKey :: forall k a b. (k -> a -> Maybe b) -> Map k a -> Map k b
m_mapMaybeWithKey = I.mapMaybeWithKey

-- m_mapWithKey :: forall k a b. (k -> a -> b) -> Map k a -> Map k b
m_mapWithKey = I.mapWithKey

-- m_mergeWithKey :: forall k a b c. Ord k => (k -> a -> b -> Maybe c) -> (Map k a -> Map k c) -> (Map k b -> Map k c) -> Map k a -> Map k b -> Map k c
m_mergeWithKey = I.mergeWithKey

-- m_singleton :: forall k a. k -> a -> Map k a
m_singleton = I.singleton

-- m_unionWith :: forall a k. Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
m_unionWith = I.unionWith

-- m_unionWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
m_unionWithKey = I.unionWithKey

-- m_unionsWith :: forall a k. Ord k => (a -> a -> a) -> [Map k a] -> Map k a
m_unionsWith = I.unionsWith

-- m_update :: forall a k. Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
m_update = I.update

-- m_updateAt :: forall k a. (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
m_updateAt = I.updateAt

-- m_updateLookupWithKey :: forall k a. Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
m_updateLookupWithKey = I.updateLookupWithKey

-- m_updateMax :: forall a k. (a -> Maybe a) -> Map k a -> Map k a
m_updateMax = I.updateMax

-- m_updateMaxWithKey :: forall k a. (k -> a -> Maybe a) -> Map k a -> Map k a
m_updateMaxWithKey = I.updateMaxWithKey

-- m_updateMin :: forall a k. (a -> Maybe a) -> Map k a -> Map k a
m_updateMin = I.updateMin

-- m_updateMinWithKey :: forall k a. (k -> a -> Maybe a) -> Map k a -> Map k a
m_updateMinWithKey = I.updateMinWithKey

-- m_updateWithKey :: forall k a. Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
m_updateWithKey = I.updateWithKey

type MMap a b = I.Map a b
