module Data.Map.Strict.AsMap where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import Data.Map.Strict as I

-- (!) :: forall k a. Ord k => Map k a -> k -> a
(!) = (I.!)

-- (\\) :: forall k a b. Ord k => Map k a -> Map k b -> Map k a
(\\) = (I.\\)

-- map_assocs :: forall k a. Map k a -> [(k, a)]
map_assocs = I.assocs

-- map_delete :: forall k a. Ord k => k -> Map k a -> Map k a
map_delete = I.delete

-- map_deleteAt :: forall k a. Int -> Map k a -> Map k a
map_deleteAt = I.deleteAt

-- map_deleteFindMax :: forall k a. Map k a -> ((k, a), Map k a)
map_deleteFindMax = I.deleteFindMax

-- map_deleteFindMin :: forall k a. Map k a -> ((k, a), Map k a)
map_deleteFindMin = I.deleteFindMin

-- map_deleteMax :: forall k a. Map k a -> Map k a
map_deleteMax = I.deleteMax

-- map_deleteMin :: forall k a. Map k a -> Map k a
map_deleteMin = I.deleteMin

-- map_difference :: forall k a b. Ord k => Map k a -> Map k b -> Map k a
map_difference = I.difference

-- map_elemAt :: forall k a. Int -> Map k a -> (k, a)
map_elemAt = I.elemAt

-- map_elems :: forall k a. Map k a -> [a]
map_elems = I.elems

-- map_empty :: forall k a. Map k a
map_empty = I.empty

-- map_filter :: forall a k. (a -> Bool) -> Map k a -> Map k a
map_filter = I.filter

-- map_filterWithKey :: forall k a. (k -> a -> Bool) -> Map k a -> Map k a
map_filterWithKey = I.filterWithKey

-- map_findIndex :: forall k a. Ord k => k -> Map k a -> Int
map_findIndex = I.findIndex

-- map_findMax :: forall k a. Map k a -> (k, a)
map_findMax = I.findMax

-- map_findMin :: forall k a. Map k a -> (k, a)
map_findMin = I.findMin

-- map_foldMapWithKey :: forall k a m. Monoid m => (k -> a -> m) -> Map k a -> m
map_foldMapWithKey = I.foldMapWithKey

-- map_foldl :: forall a b k. (a -> b -> a) -> a -> Map k b -> a
map_foldl = I.foldl

-- map_foldl' :: forall a b k. (a -> b -> a) -> a -> Map k b -> a
map_foldl' = I.foldl'

-- map_foldlWithKey :: forall a k b. (a -> k -> b -> a) -> a -> Map k b -> a
map_foldlWithKey = I.foldlWithKey

-- map_foldlWithKey' :: forall a k b. (a -> k -> b -> a) -> a -> Map k b -> a
map_foldlWithKey' = I.foldlWithKey'

-- map_foldr :: forall a b k. (a -> b -> b) -> b -> Map k a -> b
map_foldr = I.foldr

-- map_foldr' :: forall a b k. (a -> b -> b) -> b -> Map k a -> b
map_foldr' = I.foldr'

-- map_foldrWithKey :: forall k a b. (k -> a -> b -> b) -> b -> Map k a -> b
map_foldrWithKey = I.foldrWithKey

-- map_foldrWithKey' :: forall k a b. (k -> a -> b -> b) -> b -> Map k a -> b
map_foldrWithKey' = I.foldrWithKey'

-- map_intersection :: forall k a b. Ord k => Map k a -> Map k b -> Map k a
map_intersection = I.intersection

-- map_isProperSubmapOf :: forall k a. (Ord k, Eq a) => Map k a -> Map k a -> Bool
map_isProperSubmapOf = I.isProperSubmapOf

-- map_isProperSubmapOfBy :: forall a b k. Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
map_isProperSubmapOfBy = I.isProperSubmapOfBy

-- map_isSubmapOf :: forall k a. (Ord k, Eq a) => Map k a -> Map k a -> Bool
map_isSubmapOf = I.isSubmapOf

-- map_isSubmapOfBy :: forall a b k. Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
map_isSubmapOfBy = I.isSubmapOfBy

-- map_keys :: forall k a. Map k a -> [k]
map_keys = I.keys

-- map_keysSet :: forall k a. Map k a -> Set k
map_keysSet = I.keysSet

-- map_lookup :: forall k a. Ord k => k -> Map k a -> Maybe a
map_lookup = I.lookup

-- map_lookupGE :: forall k v. Ord k => k -> Map k v -> Maybe (k, v)
map_lookupGE = I.lookupGE

-- map_lookupGT :: forall k v. Ord k => k -> Map k v -> Maybe (k, v)
map_lookupGT = I.lookupGT

-- map_lookupIndex :: forall k a. Ord k => k -> Map k a -> Maybe Int
map_lookupIndex = I.lookupIndex

-- map_lookupLE :: forall k v. Ord k => k -> Map k v -> Maybe (k, v)
map_lookupLE = I.lookupLE

-- map_lookupLT :: forall k v. Ord k => k -> Map k v -> Maybe (k, v)
map_lookupLT = I.lookupLT

-- map_mapKeys :: forall k1 k2 a. Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
map_mapKeys = I.mapKeys

-- map_mapKeysMonotonic :: forall k1 k2 a. (k1 -> k2) -> Map k1 a -> Map k2 a
map_mapKeysMonotonic = I.mapKeysMonotonic

-- map_maxView :: forall k a. Map k a -> Maybe (a, Map k a)
map_maxView = I.maxView

-- map_maxViewWithKey :: forall k a. Map k a -> Maybe ((k, a), Map k a)
map_maxViewWithKey = I.maxViewWithKey

-- map_member :: forall k a. Ord k => k -> Map k a -> Bool
map_member = I.member

-- map_minView :: forall k a. Map k a -> Maybe (a, Map k a)
map_minView = I.minView

-- map_minViewWithKey :: forall k a. Map k a -> Maybe ((k, a), Map k a)
map_minViewWithKey = I.minViewWithKey

-- map_notMember :: forall k a. Ord k => k -> Map k a -> Bool
map_notMember = I.notMember

-- map_null :: forall k a. Map k a -> Bool
map_null = I.null

-- map_partition :: forall a k. (a -> Bool) -> Map k a -> (Map k a, Map k a)
map_partition = I.partition

-- map_partitionWithKey :: forall k a. (k -> a -> Bool) -> Map k a -> (Map k a, Map k a)
map_partitionWithKey = I.partitionWithKey

-- map_showTree :: forall k a. (Show k, Show a) => Map k a -> String
map_showTree = I.showTree

-- map_showTreeWith :: forall k a. (k -> a -> String) -> Bool -> Bool -> Map k a -> String
map_showTreeWith = I.showTreeWith

-- map_size :: forall k a. Map k a -> Int
map_size = I.size

-- map_split :: forall k a. Ord k => k -> Map k a -> (Map k a, Map k a)
map_split = I.split

-- map_splitLookup :: forall k a. Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)
map_splitLookup = I.splitLookup

-- map_splitRoot :: forall k b. Map k b -> [Map k b]
map_splitRoot = I.splitRoot

-- map_toAscList :: forall k a. Map k a -> [(k, a)]
map_toAscList = I.toAscList

-- map_toDescList :: forall k a. Map k a -> [(k, a)]
map_toDescList = I.toDescList

-- map_toList :: forall k a. Map k a -> [(k, a)]
map_toList = I.toList

-- map_traverseWithKey :: forall k a (t :: * -> *) b. Applicative t => (k -> a -> t b) -> Map k a -> t (Map k b)
map_traverseWithKey = I.traverseWithKey

-- map_union :: forall k a. Ord k => Map k a -> Map k a -> Map k a
map_union = I.union

-- map_unions :: forall k a. Ord k => [Map k a] -> Map k a
map_unions = I.unions

-- map_valid :: forall k a. Ord k => Map k a -> Bool
map_valid = I.valid

-- map_adjust :: forall a k. Ord k => (a -> a) -> k -> Map k a -> Map k a
map_adjust = I.adjust

-- map_adjustWithKey :: forall k a. Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
map_adjustWithKey = I.adjustWithKey

-- map_alter :: forall a k. Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
map_alter = I.alter

-- map_differenceWith :: forall a b k. Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
map_differenceWith = I.differenceWith

-- map_differenceWithKey :: forall k a b. Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
map_differenceWithKey = I.differenceWithKey

-- map_findWithDefault :: forall a k. Ord k => a -> k -> Map k a -> a
map_findWithDefault = I.findWithDefault

-- map_fromAscList :: forall k a. Eq k => [(k, a)] -> Map k a
map_fromAscList = I.fromAscList

-- map_fromAscListWith :: forall a k. Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
map_fromAscListWith = I.fromAscListWith

-- map_fromAscListWithKey :: forall k a. Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
map_fromAscListWithKey = I.fromAscListWithKey

-- map_fromDistinctAscList :: forall k a. [(k, a)] -> Map k a
map_fromDistinctAscList = I.fromDistinctAscList

-- map_fromList :: forall k a. Ord k => [(k, a)] -> Map k a
map_fromList = I.fromList

-- map_fromListWith :: forall a k. Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
map_fromListWith = I.fromListWith

-- map_fromListWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
map_fromListWithKey = I.fromListWithKey

-- map_fromSet :: forall k a. (k -> a) -> Set k -> Map k a
map_fromSet = I.fromSet

-- map_insert :: forall k a. Ord k => k -> a -> Map k a -> Map k a
map_insert = I.insert

-- map_insertLookupWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
map_insertLookupWithKey = I.insertLookupWithKey

-- map_insertWith :: forall a k. Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
map_insertWith = I.insertWith

-- map_insertWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
map_insertWithKey = I.insertWithKey

-- map_intersectionWith :: forall a b c k. Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
map_intersectionWith = I.intersectionWith

-- map_intersectionWithKey :: forall k a b c. Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
map_intersectionWithKey = I.intersectionWithKey

-- map_map :: forall a b k. (a -> b) -> Map k a -> Map k b
map_map = I.map

-- map_mapAccum :: forall a b c k. (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
map_mapAccum = I.mapAccum

-- map_mapAccumRWithKey :: forall a k b c. (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
map_mapAccumRWithKey = I.mapAccumRWithKey

-- map_mapAccumWithKey :: forall a k b c. (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
map_mapAccumWithKey = I.mapAccumWithKey

-- map_mapEither :: forall a b c k. (a -> Either b c) -> Map k a -> (Map k b, Map k c)
map_mapEither = I.mapEither

-- map_mapEitherWithKey :: forall k a b c. (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)
map_mapEitherWithKey = I.mapEitherWithKey

-- map_mapKeysWith :: forall a k1 k2. Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
map_mapKeysWith = I.mapKeysWith

-- map_mapMaybe :: forall a b k. (a -> Maybe b) -> Map k a -> Map k b
map_mapMaybe = I.mapMaybe

-- map_mapMaybeWithKey :: forall k a b. (k -> a -> Maybe b) -> Map k a -> Map k b
map_mapMaybeWithKey = I.mapMaybeWithKey

-- map_mapWithKey :: forall k a b. (k -> a -> b) -> Map k a -> Map k b
map_mapWithKey = I.mapWithKey

-- map_mergeWithKey :: forall k a b c. Ord k => (k -> a -> b -> Maybe c) -> (Map k a -> Map k c) -> (Map k b -> Map k c) -> Map k a -> Map k b -> Map k c
map_mergeWithKey = I.mergeWithKey

-- map_singleton :: forall k a. k -> a -> Map k a
map_singleton = I.singleton

-- map_unionWith :: forall a k. Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
map_unionWith = I.unionWith

-- map_unionWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
map_unionWithKey = I.unionWithKey

-- map_unionsWith :: forall a k. Ord k => (a -> a -> a) -> [Map k a] -> Map k a
map_unionsWith = I.unionsWith

-- map_update :: forall a k. Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
map_update = I.update

-- map_updateAt :: forall k a. (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
map_updateAt = I.updateAt

-- map_updateLookupWithKey :: forall k a. Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
map_updateLookupWithKey = I.updateLookupWithKey

-- map_updateMax :: forall a k. (a -> Maybe a) -> Map k a -> Map k a
map_updateMax = I.updateMax

-- map_updateMaxWithKey :: forall k a. (k -> a -> Maybe a) -> Map k a -> Map k a
map_updateMaxWithKey = I.updateMaxWithKey

-- map_updateMin :: forall a k. (a -> Maybe a) -> Map k a -> Map k a
map_updateMin = I.updateMin

-- map_updateMinWithKey :: forall k a. (k -> a -> Maybe a) -> Map k a -> Map k a
map_updateMinWithKey = I.updateMinWithKey

-- map_updateWithKey :: forall k a. Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
map_updateWithKey = I.updateWithKey

type MapMap a b = I.Map a b
