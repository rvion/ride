module Data.Set.AsSet where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import           Data.Set as I

-- set_delete :: forall a. Ord a => a -> Set a -> Set a
set_delete = I.delete

-- set_deleteAt :: forall a. Int -> Set a -> Set a
set_deleteAt = I.deleteAt

-- set_deleteFindMax :: forall a. Set a -> (a, Set a)
set_deleteFindMax = I.deleteFindMax

-- set_deleteFindMin :: forall a. Set a -> (a, Set a)
set_deleteFindMin = I.deleteFindMin

-- set_deleteMax :: forall a. Set a -> Set a
set_deleteMax = I.deleteMax

-- set_deleteMin :: forall a. Set a -> Set a
set_deleteMin = I.deleteMin

-- set_difference :: forall a. Ord a => Set a -> Set a -> Set a
set_difference = I.difference

-- set_elemAt :: forall a. Int -> Set a -> a
set_elemAt = I.elemAt

-- set_elems :: forall a. Set a -> [a]
set_elems = I.elems

-- set_empty :: forall a. Set a
set_empty = I.empty

-- set_filter :: forall a. (a -> Bool) -> Set a -> Set a
set_filter = I.filter

-- set_findIndex :: forall a. Ord a => a -> Set a -> Int
set_findIndex = I.findIndex

-- set_findMax :: forall a. Set a -> a
set_findMax = I.findMax

-- set_findMin :: forall a. Set a -> a
set_findMin = I.findMin

-- set_fold :: forall a b. (a -> b -> b) -> b -> Set a -> b
set_fold = I.fold

-- set_foldl :: forall a b. (a -> b -> a) -> a -> Set b -> a
set_foldl = I.foldl

-- set_foldl' :: forall a b. (a -> b -> a) -> a -> Set b -> a
set_foldl' = I.foldl'

-- set_foldr :: forall a b. (a -> b -> b) -> b -> Set a -> b
set_foldr = I.foldr

-- set_foldr' :: forall a b. (a -> b -> b) -> b -> Set a -> b
set_foldr' = I.foldr'

-- set_fromAscList :: forall a. Eq a => [a] -> Set a
set_fromAscList = I.fromAscList

-- set_fromDistinctAscList :: forall a. [a] -> Set a
set_fromDistinctAscList = I.fromDistinctAscList

-- set_fromList :: forall a. Ord a => [a] -> Set a
set_fromList = I.fromList

-- set_insert :: forall a. Ord a => a -> Set a -> Set a
set_insert = I.insert

-- set_intersection :: forall a. Ord a => Set a -> Set a -> Set a
set_intersection = I.intersection

-- set_isProperSubsetOf :: forall a. Ord a => Set a -> Set a -> Bool
set_isProperSubsetOf = I.isProperSubsetOf

-- set_isSubsetOf :: forall a. Ord a => Set a -> Set a -> Bool
set_isSubsetOf = I.isSubsetOf

-- set_lookupGE :: forall a. Ord a => a -> Set a -> Maybe a
set_lookupGE = I.lookupGE

-- set_lookupGT :: forall a. Ord a => a -> Set a -> Maybe a
set_lookupGT = I.lookupGT

-- set_lookupIndex :: forall a. Ord a => a -> Set a -> Maybe Int
set_lookupIndex = I.lookupIndex

-- set_lookupLE :: forall a. Ord a => a -> Set a -> Maybe a
set_lookupLE = I.lookupLE

-- set_lookupLT :: forall a. Ord a => a -> Set a -> Maybe a
set_lookupLT = I.lookupLT

-- set_map :: forall a b. Ord b => (a -> b) -> Set a -> Set b
set_map = I.map

-- set_mapMonotonic :: forall a b. (a -> b) -> Set a -> Set b
set_mapMonotonic = I.mapMonotonic

-- set_maxView :: forall a. Set a -> Maybe (a, Set a)
set_maxView = I.maxView

-- set_member :: forall a. Ord a => a -> Set a -> Bool
set_member = I.member

-- set_minView :: forall a. Set a -> Maybe (a, Set a)
set_minView = I.minView

-- set_notMember :: forall a. Ord a => a -> Set a -> Bool
set_notMember = I.notMember

-- set_null :: forall a. Set a -> Bool
set_null = I.null

-- set_partition :: forall a. (a -> Bool) -> Set a -> (Set a, Set a)
set_partition = I.partition

-- set_showTree :: forall a. Show a => Set a -> String
set_showTree = I.showTree

-- set_showTreeWith :: forall a. Show a => Bool -> Bool -> Set a -> String
set_showTreeWith = I.showTreeWith

-- set_singleton :: forall a. a -> Set a
set_singleton = I.singleton

-- set_size :: forall a. Set a -> Int
set_size = I.size

-- set_split :: forall a. Ord a => a -> Set a -> (Set a, Set a)
set_split = I.split

-- set_splitMember :: forall a. Ord a => a -> Set a -> (Set a, Bool, Set a)
set_splitMember = I.splitMember

-- set_splitRoot :: forall a. Set a -> [Set a]
set_splitRoot = I.splitRoot

-- set_toAscList :: forall a. Set a -> [a]
set_toAscList = I.toAscList

-- set_toDescList :: forall a. Set a -> [a]
set_toDescList = I.toDescList

-- set_toList :: forall a. Set a -> [a]
set_toList = I.toList

-- set_union :: forall a. Ord a => Set a -> Set a -> Set a
set_union = I.union

-- set_unions :: forall a. Ord a => [Set a] -> Set a
set_unions = I.unions

-- set_valid :: forall a. Ord a => Set a -> Bool
set_valid = I.valid

type SetSet a = I.Set a
