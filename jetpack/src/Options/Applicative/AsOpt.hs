module Options.Applicative.AsOpt where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import Options.Applicative as I

-- opt_optional :: forall (f :: * -> *) a. Alternative f => f a -> f (Maybe a)
opt_optional = I.optional

-- (<$>) :: forall a b (f :: * -> *). Functor f => (a -> b) -> f a -> f b
(<$>) = (I.<$>)

-- (<>) :: forall m. Monoid m => m -> m -> m
(<>) = (I.<>)

-- (<**>) :: forall (f :: * -> *) a b. Applicative f => f a -> f (a -> b) -> f b
(<**>) = (I.<**>)

-- opt_liftA :: forall a b (f :: * -> *). Applicative f => (a -> b) -> f a -> f b
opt_liftA = I.liftA

-- opt_liftA2 :: forall a b c (f :: * -> *). Applicative f => (a -> b -> c) -> f a -> f b -> f c
opt_liftA2 = I.liftA2

-- opt_liftA3 :: forall a b c d (f :: * -> *). Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
opt_liftA3 = I.liftA3

-- opt_abortOption :: forall a. ParseError -> Mod OptionFields (a -> a) -> Parser (a -> a)
opt_abortOption = I.abortOption

-- opt_action :: forall (f :: * -> *) a. HasCompleter f => String -> Mod f a
opt_action = I.action

-- opt_argument :: forall a. ReadM a -> Mod ArgumentFields a -> Parser a
opt_argument = I.argument

-- opt_auto :: forall a. Read a => ReadM a
opt_auto = I.auto

-- opt_briefDesc :: forall a. InfoMod a
opt_briefDesc = I.briefDesc

-- opt_columns :: Int -> PrefsMod
opt_columns = I.columns

-- opt_command :: forall a. String -> ParserInfo a -> Mod CommandFields a
opt_command = I.command

-- opt_completeWith :: forall (f :: * -> *) a. HasCompleter f => [String] -> Mod f a
opt_completeWith = I.completeWith

-- opt_completer :: forall (f :: * -> *) a. HasCompleter f => Completer -> Mod f a
opt_completer = I.completer

-- opt_disabled :: forall a. ReadM a
opt_disabled = I.disabled

-- opt_disambiguate :: PrefsMod
opt_disambiguate = I.disambiguate

-- opt_eitherReader :: forall a. (String -> Either String a) -> ReadM a
opt_eitherReader = I.eitherReader

-- opt_failureCode :: forall a. Int -> InfoMod a
opt_failureCode = I.failureCode

-- opt_flag :: forall a. a -> a -> Mod FlagFields a -> Parser a
opt_flag = I.flag

-- opt_flag' :: forall a. a -> Mod FlagFields a -> Parser a
opt_flag' = I.flag'

-- opt_footer :: forall a. String -> InfoMod a
opt_footer = I.footer

-- opt_footerDoc :: forall a. Maybe Doc -> InfoMod a
opt_footerDoc = I.footerDoc

-- opt_fullDesc :: forall a. InfoMod a
opt_fullDesc = I.fullDesc

-- opt_header :: forall a. String -> InfoMod a
opt_header = I.header

-- opt_headerDoc :: forall a. Maybe Doc -> InfoMod a
opt_headerDoc = I.headerDoc

-- opt_help :: forall (f :: * -> *) a. String -> Mod f a
opt_help = I.help

-- opt_helpDoc :: forall (f :: * -> *) a. Maybe Doc -> Mod f a
opt_helpDoc = I.helpDoc

-- opt_hidden :: forall (f :: * -> *) a. Mod f a
opt_hidden = I.hidden

-- opt_idm :: forall m. Monoid m => m
opt_idm = I.idm

-- opt_info :: forall a. Parser a -> InfoMod a -> ParserInfo a
opt_info = I.info

-- opt_infoOption :: forall a. String -> Mod OptionFields (a -> a) -> Parser (a -> a)
opt_infoOption = I.infoOption

-- opt_long :: forall (f :: * -> *) a. HasName f => String -> Mod f a
opt_long = I.long

-- opt_metavar :: forall (f :: * -> *) a. HasMetavar f => String -> Mod f a
opt_metavar = I.metavar

-- opt_multiSuffix :: String -> PrefsMod
opt_multiSuffix = I.multiSuffix

-- opt_noArgError :: forall a. ParseError -> Mod OptionFields a
opt_noArgError = I.noArgError

-- opt_noBacktrack :: PrefsMod
opt_noBacktrack = I.noBacktrack

-- opt_noIntersperse :: forall a. InfoMod a
opt_noIntersperse = I.noIntersperse

-- opt_option :: forall a. ReadM a -> Mod OptionFields a -> Parser a
opt_option = I.option

-- opt_prefs :: PrefsMod -> ParserPrefs
opt_prefs = I.prefs

-- opt_progDesc :: forall a. String -> InfoMod a
opt_progDesc = I.progDesc

-- opt_progDescDoc :: forall a. Maybe Doc -> InfoMod a
opt_progDescDoc = I.progDescDoc

-- opt_short :: forall (f :: * -> *) a. HasName f => Char -> Mod f a
opt_short = I.short

-- opt_showDefault :: forall (f :: * -> *) a. Show a => Mod f a
opt_showDefault = I.showDefault

-- opt_showDefaultWith :: forall a (f :: * -> *). (a -> String) -> Mod f a
opt_showDefaultWith = I.showDefaultWith

-- opt_showHelpOnError :: PrefsMod
opt_showHelpOnError = I.showHelpOnError

-- opt_str :: ReadM String
opt_str = I.str

-- opt_strArgument :: Mod ArgumentFields String -> Parser String
opt_strArgument = I.strArgument

-- opt_strOption :: Mod OptionFields String -> Parser String
opt_strOption = I.strOption

-- opt_subparser :: forall a. Mod CommandFields a -> Parser a
opt_subparser = I.subparser

-- opt_switch :: Mod FlagFields Bool -> Parser Bool
opt_switch = I.switch

-- opt_value :: forall a (f :: * -> *). HasValue f => a -> Mod f a
opt_value = I.value

-- opt_bashCompleter :: String -> Completer
opt_bashCompleter = I.bashCompleter

-- opt_listCompleter :: [String] -> Completer
opt_listCompleter = I.listCompleter

-- opt_listIOCompleter :: IO [String] -> Completer
opt_listIOCompleter = I.listIOCompleter

-- opt_internal :: forall (f :: * -> *) a. Mod f a
opt_internal = I.internal

-- opt_evalParser :: forall a. Parser a -> Maybe a
opt_evalParser = I.evalParser

-- opt_liftOpt :: forall a. Option a -> Parser a
opt_liftOpt = I.liftOpt

-- opt_mapParser :: forall a b. (forall x. OptHelpInfo -> Option x -> b) -> Parser a -> [b]
opt_mapParser = I.mapParser

-- opt_optionNames :: forall a. OptReader a -> [OptName]
opt_optionNames = I.optionNames

-- opt_runParser :: forall a (m :: * -> *). MonadP m => ArgPolicy -> Parser a -> Args -> m (a, Args)
opt_runParser = I.runParser

-- opt_runParserFully :: forall a (m :: * -> *). MonadP m => ArgPolicy -> Parser a -> Args -> m a
opt_runParserFully = I.runParserFully

-- opt_runParserInfo :: forall a (m :: * -> *). MonadP m => ParserInfo a -> Args -> m a
opt_runParserInfo = I.runParserInfo

-- opt_showOption :: OptName -> String
opt_showOption = I.showOption

-- opt_treeMapParser :: forall a b. (forall x. OptHelpInfo -> Option x -> b) -> Parser a -> OptTree b
opt_treeMapParser = I.treeMapParser

-- opt_customExecParser :: forall a. ParserPrefs -> ParserInfo a -> IO a
opt_customExecParser = I.customExecParser

-- opt_execParser :: forall a. ParserInfo a -> IO a
opt_execParser = I.execParser

-- opt_execParserPure :: forall a. ParserPrefs -> ParserInfo a -> [String] -> ParserResult a
opt_execParserPure = I.execParserPure

-- opt_getParseResult :: forall a. ParserResult a -> Maybe a
opt_getParseResult = I.getParseResult

-- opt_handleParseResult :: forall a. ParserResult a -> IO a
opt_handleParseResult = I.handleParseResult

-- opt_helper :: forall a. Parser (a -> a)
opt_helper = I.helper

-- opt_hsubparser :: forall a. Mod CommandFields a -> Parser a
opt_hsubparser = I.hsubparser

-- opt_parserFailure :: forall a. ParserPrefs -> ParserInfo a -> ParseError -> Context -> ParserFailure ParserHelp
opt_parserFailure = I.parserFailure

-- opt_renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
opt_renderFailure = I.renderFailure

-- opt_mkCompleter :: (String -> IO [String]) -> Completer
opt_mkCompleter = I.mkCompleter

-- opt_overFailure :: forall a. (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a
opt_overFailure = I.overFailure

-- opt_readerAbort :: forall a. ParseError -> ReadM a
opt_readerAbort = I.readerAbort

-- opt_readerError :: forall a. String -> ReadM a
opt_readerError = I.readerError

type OptConst a b = I.Const a b
type OptWrappedArrow a b c = I.WrappedArrow a b c
type OptWrappedMonad a b = I.WrappedMonad a b
type OptZipList a = I.ZipList a
type OptInfoMod a = I.InfoMod a
type OptPrefsMod  = I.PrefsMod
type OptArgumentFields a = I.ArgumentFields a
type OptCommandFields a = I.CommandFields a
type OptFlagFields a = I.FlagFields a
type OptMod a b = I.Mod a b
type OptOptionFields a = I.OptionFields a
type OptCompleter  = I.Completer
type OptCompletionResult  = I.CompletionResult
type OptParseError  = I.ParseError
type OptParser a = I.Parser a
type OptParserFailure a = I.ParserFailure a
type OptParserInfo a = I.ParserInfo a
type OptParserPrefs  = I.ParserPrefs
type OptParserResult a = I.ParserResult a
type OptReadM a = I.ReadM a
