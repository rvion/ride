module Control.Concurrent.STM.AsStm where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import qualified Control.Concurrent.STM as I


-- stm_registerDelay :: Int -> IO (TVar Bool)
stm_registerDelay = I.registerDelay

-- stm_always :: STM Bool -> STM ()
stm_always = I.always

-- stm_alwaysSucceeds :: forall a. STM a -> STM ()
stm_alwaysSucceeds = I.alwaysSucceeds

-- stm_atomically :: forall a. STM a -> IO a
stm_atomically = I.atomically

-- stm_catchSTM :: forall a e. Exception e => STM a -> (e -> STM a) -> STM a
stm_catchSTM = I.catchSTM

-- stm_newTVar :: forall a. a -> STM (TVar a)
stm_newTVar = I.newTVar

-- stm_newTVarIO :: forall a. a -> IO (TVar a)
stm_newTVarIO = I.newTVarIO

-- stm_orElse :: forall a. STM a -> STM a -> STM a
stm_orElse = I.orElse

-- stm_readTVar :: forall a. TVar a -> STM a
stm_readTVar = I.readTVar

-- stm_readTVarIO :: forall a. TVar a -> IO a
stm_readTVarIO = I.readTVarIO

-- stm_retry :: forall a. STM a
stm_retry = I.retry

-- stm_throwSTM :: forall e a. Exception e => e -> STM a
stm_throwSTM = I.throwSTM

-- stm_writeTVar :: forall a. TVar a -> a -> STM ()
stm_writeTVar = I.writeTVar

-- stm_isEmptyTBQueue :: forall a. TBQueue a -> STM Bool
stm_isEmptyTBQueue = I.isEmptyTBQueue

-- stm_isFullTBQueue :: forall a. TBQueue a -> STM Bool
stm_isFullTBQueue = I.isFullTBQueue

-- stm_newTBQueue :: forall a. Int -> STM (TBQueue a)
stm_newTBQueue = I.newTBQueue

-- stm_newTBQueueIO :: forall a. Int -> IO (TBQueue a)
stm_newTBQueueIO = I.newTBQueueIO

-- stm_peekTBQueue :: forall a. TBQueue a -> STM a
stm_peekTBQueue = I.peekTBQueue

-- stm_readTBQueue :: forall a. TBQueue a -> STM a
stm_readTBQueue = I.readTBQueue

-- stm_tryPeekTBQueue :: forall a. TBQueue a -> STM (Maybe a)
stm_tryPeekTBQueue = I.tryPeekTBQueue

-- stm_tryReadTBQueue :: forall a. TBQueue a -> STM (Maybe a)
stm_tryReadTBQueue = I.tryReadTBQueue

-- stm_unGetTBQueue :: forall a. TBQueue a -> a -> STM ()
stm_unGetTBQueue = I.unGetTBQueue

-- stm_writeTBQueue :: forall a. TBQueue a -> a -> STM ()
stm_writeTBQueue = I.writeTBQueue

-- stm_cloneTChan :: forall a. TChan a -> STM (TChan a)
stm_cloneTChan = I.cloneTChan

-- stm_dupTChan :: forall a. TChan a -> STM (TChan a)
stm_dupTChan = I.dupTChan

-- stm_isEmptyTChan :: forall a. TChan a -> STM Bool
stm_isEmptyTChan = I.isEmptyTChan

-- stm_newBroadcastTChan :: forall a. STM (TChan a)
stm_newBroadcastTChan = I.newBroadcastTChan

-- stm_newBroadcastTChanIO :: forall a. IO (TChan a)
stm_newBroadcastTChanIO = I.newBroadcastTChanIO

-- stm_newTChan :: forall a. STM (TChan a)
stm_newTChan = I.newTChan

-- stm_newTChanIO :: forall a. IO (TChan a)
stm_newTChanIO = I.newTChanIO

-- stm_peekTChan :: forall a. TChan a -> STM a
stm_peekTChan = I.peekTChan

-- stm_readTChan :: forall a. TChan a -> STM a
stm_readTChan = I.readTChan

-- stm_tryPeekTChan :: forall a. TChan a -> STM (Maybe a)
stm_tryPeekTChan = I.tryPeekTChan

-- stm_tryReadTChan :: forall a. TChan a -> STM (Maybe a)
stm_tryReadTChan = I.tryReadTChan

-- stm_unGetTChan :: forall a. TChan a -> a -> STM ()
stm_unGetTChan = I.unGetTChan

-- stm_writeTChan :: forall a. TChan a -> a -> STM ()
stm_writeTChan = I.writeTChan

-- stm_isEmptyTMVar :: forall a. TMVar a -> STM Bool
stm_isEmptyTMVar = I.isEmptyTMVar

-- stm_mkWeakTMVar :: forall a. TMVar a -> IO () -> IO (Weak (TMVar a))
stm_mkWeakTMVar = I.mkWeakTMVar

-- stm_newEmptyTMVar :: forall a. STM (TMVar a)
stm_newEmptyTMVar = I.newEmptyTMVar

-- stm_newEmptyTMVarIO :: forall a. IO (TMVar a)
stm_newEmptyTMVarIO = I.newEmptyTMVarIO

-- stm_newTMVar :: forall a. a -> STM (TMVar a)
stm_newTMVar = I.newTMVar

-- stm_newTMVarIO :: forall a. a -> IO (TMVar a)
stm_newTMVarIO = I.newTMVarIO

-- stm_putTMVar :: forall a. TMVar a -> a -> STM ()
stm_putTMVar = I.putTMVar

-- stm_readTMVar :: forall a. TMVar a -> STM a
stm_readTMVar = I.readTMVar

-- stm_swapTMVar :: forall a. TMVar a -> a -> STM a
stm_swapTMVar = I.swapTMVar

-- stm_takeTMVar :: forall a. TMVar a -> STM a
stm_takeTMVar = I.takeTMVar

-- stm_tryPutTMVar :: forall a. TMVar a -> a -> STM Bool
stm_tryPutTMVar = I.tryPutTMVar

-- stm_tryReadTMVar :: forall a. TMVar a -> STM (Maybe a)
stm_tryReadTMVar = I.tryReadTMVar

-- stm_tryTakeTMVar :: forall a. TMVar a -> STM (Maybe a)
stm_tryTakeTMVar = I.tryTakeTMVar

-- stm_isEmptyTQueue :: forall a. TQueue a -> STM Bool
stm_isEmptyTQueue = I.isEmptyTQueue

-- stm_newTQueue :: forall a. STM (TQueue a)
stm_newTQueue = I.newTQueue

-- stm_newTQueueIO :: forall a. IO (TQueue a)
stm_newTQueueIO = I.newTQueueIO

-- stm_peekTQueue :: forall a. TQueue a -> STM a
stm_peekTQueue = I.peekTQueue

-- stm_readTQueue :: forall a. TQueue a -> STM a
stm_readTQueue = I.readTQueue

-- stm_tryPeekTQueue :: forall a. TQueue a -> STM (Maybe a)
stm_tryPeekTQueue = I.tryPeekTQueue

-- stm_tryReadTQueue :: forall a. TQueue a -> STM (Maybe a)
stm_tryReadTQueue = I.tryReadTQueue

-- stm_unGetTQueue :: forall a. TQueue a -> a -> STM ()
stm_unGetTQueue = I.unGetTQueue

-- stm_writeTQueue :: forall a. TQueue a -> a -> STM ()
stm_writeTQueue = I.writeTQueue

-- stm_mkWeakTVar :: forall a. TVar a -> IO () -> IO (Weak (TVar a))
stm_mkWeakTVar = I.mkWeakTVar

-- stm_modifyTVar :: forall a. TVar a -> (a -> a) -> STM ()
stm_modifyTVar = I.modifyTVar

-- stm_modifyTVar' :: forall a. TVar a -> (a -> a) -> STM ()
stm_modifyTVar' = I.modifyTVar'

-- stm_swapTVar :: forall a. TVar a -> a -> STM a
stm_swapTVar = I.swapTVar

-- stm_check :: Bool -> STM ()
stm_check = I.check

type StmSTM a = I.STM a

type StmTVar a = I.TVar a

type StmTArray a b = I.TArray a b

type StmTBQueue a = I.TBQueue a

type StmTChan a = I.TChan a

type StmTMVar a = I.TMVar a

type StmTQueue a = I.TQueue a
