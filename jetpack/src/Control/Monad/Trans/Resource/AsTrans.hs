module Control.Monad.Trans.Resource.AsTrans
  ( -- unqualified class re-export
  I.MonadThrow(I.throwM), I.MonadBaseControl(), I.MonadResource(I.liftResourceT)
  , module Control.Monad.Trans.Resource.AsTrans
  ) where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import qualified Control.Monad.Trans.Resource as I


-- trans_allocate :: forall a (m :: * -> *). MonadResource m => IO a -> (a -> IO ()) -> m (ReleaseKey, a)
trans_allocate = I.allocate

-- trans_closeInternalState :: forall (m :: * -> *). MonadBase IO m => InternalState -> m ()
trans_closeInternalState = I.closeInternalState

-- trans_createInternalState :: forall (m :: * -> *). MonadBase IO m => m InternalState
trans_createInternalState = I.createInternalState

-- trans_getInternalState :: forall (m :: * -> *). Monad m => ResourceT m InternalState
trans_getInternalState = I.getInternalState

-- trans_joinResourceT :: forall (m :: * -> *) a. ResourceT (ResourceT m) a -> ResourceT m a
trans_joinResourceT = I.joinResourceT

-- trans_monadThrow :: forall e (m :: * -> *) a. (Exception e, MonadThrow m) => e -> m a
trans_monadThrow = I.monadThrow

-- trans_register :: forall (m :: * -> *). MonadResource m => IO () -> m ReleaseKey
trans_register = I.register

-- trans_release :: forall (m :: * -> *). MonadIO m => ReleaseKey -> m ()
trans_release = I.release

-- trans_resourceForkIO :: forall (m :: * -> *). MonadBaseControl IO m => ResourceT m () -> ResourceT m ThreadId
trans_resourceForkIO = I.resourceForkIO

-- trans_resourceMask :: forall b (m :: * -> *). MonadResource m => ((forall a. ResourceT IO a -> ResourceT IO a) -> ResourceT IO b) -> m b
trans_resourceMask = I.resourceMask

-- trans_runException :: forall a. ExceptionT Identity a -> Either SomeException a
trans_runException = I.runException

-- trans_runExceptionT :: forall (m :: * -> *) a. ExceptionT m a -> m (Either SomeException a)
trans_runExceptionT = I.runExceptionT

-- trans_runExceptionT_ :: forall (m :: * -> *) a. Monad m => ExceptionT m a -> m a
trans_runExceptionT_ = I.runExceptionT_

-- trans_runException_ :: forall a. ExceptionT Identity a -> a
trans_runException_ = I.runException_

-- trans_runInternalState :: forall (m :: * -> *) a. ResourceT m a -> InternalState -> m a
trans_runInternalState = I.runInternalState

-- trans_runResourceT :: forall (m :: * -> *) a. MonadBaseControl IO m => ResourceT m a -> m a
trans_runResourceT = I.runResourceT

-- trans_unprotect :: forall (m :: * -> *). MonadIO m => ReleaseKey -> m (Maybe (IO ()))
trans_unprotect = I.unprotect

-- trans_withInternalState :: forall (m :: * -> *) a. (InternalState -> m a) -> ResourceT m a
trans_withInternalState = I.withInternalState

-- trans_transResourceT :: forall (m :: * -> *) a (n :: * -> *) b. (m a -> n b) -> ResourceT m a -> ResourceT n b
trans_transResourceT = I.transResourceT

type TransExceptionT  = I.ExceptionT

type TransInternalState  = I.InternalState

type TransMonadResourceBase a = I.MonadResourceBase a

type TransInvalidAccess  = I.InvalidAccess
get_trans_functionName o = I.functionName o
set_trans_functionName x o = o { I.functionName = x}

-- constructor :: String -> InvalidAccess
trans_mk'InvalidAccess =  I.InvalidAccess
pattern TransInvalidAccess a <-  I.InvalidAccess a

type TransReleaseKey  = I.ReleaseKey

type TransResIO a = I.ResIO a

type TransResourceT a b = I.ResourceT a b
