module Control.Monad.Trans.State.Lazy.AsTrans where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import qualified Control.Monad.Trans.State.Lazy as I


-- trans_evalState :: forall s a. State s a -> s -> a
trans_evalState = I.evalState

-- trans_evalStateT :: forall s (m :: * -> *) a. Monad m => StateT s m a -> s -> m a
trans_evalStateT = I.evalStateT

-- trans_execState :: forall s a. State s a -> s -> s
trans_execState = I.execState

-- trans_execStateT :: forall s (m :: * -> *) a. Monad m => StateT s m a -> s -> m s
trans_execStateT = I.execStateT

-- trans_get :: forall s (m :: * -> *). Monad m => StateT s m s
trans_get = I.get

-- trans_gets :: forall s a (m :: * -> *). Monad m => (s -> a) -> StateT s m a
trans_gets = I.gets

-- trans_liftCallCC :: forall (m :: * -> *) a s b. CallCC m (a, s) (b, s) -> CallCC (StateT s m) a b
trans_liftCallCC = I.liftCallCC

-- trans_liftCallCC' :: forall (m :: * -> *) a s b. CallCC m (a, s) (b, s) -> CallCC (StateT s m) a b
trans_liftCallCC' = I.liftCallCC'

-- trans_liftCatch :: forall e (m :: * -> *) a s. Catch e m (a, s) -> Catch e (StateT s m) a
trans_liftCatch = I.liftCatch

-- trans_liftListen :: forall w (m :: * -> *) a s. Monad m => Listen w m (a, s) -> Listen w (StateT s m) a
trans_liftListen = I.liftListen

-- trans_liftPass :: forall w (m :: * -> *) a s. Monad m => Pass w m (a, s) -> Pass w (StateT s m) a
trans_liftPass = I.liftPass

-- trans_mapState :: forall a s b. ((a, s) -> (b, s)) -> State s a -> State s b
trans_mapState = I.mapState

-- trans_mapStateT :: forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
trans_mapStateT = I.mapStateT

-- trans_modify :: forall s (m :: * -> *). Monad m => (s -> s) -> StateT s m ()
trans_modify = I.modify

-- trans_modify' :: forall s (m :: * -> *). Monad m => (s -> s) -> StateT s m ()
trans_modify' = I.modify'

-- trans_put :: forall s (m :: * -> *). Monad m => s -> StateT s m ()
trans_put = I.put

-- trans_runState :: forall s a. State s a -> s -> (a, s)
trans_runState = I.runState

-- trans_state :: forall s a (m :: * -> *). Monad m => (s -> (a, s)) -> StateT s m a
trans_state = I.state

-- trans_withState :: forall s a. (s -> s) -> State s a -> State s a
trans_withState = I.withState

-- trans_withStateT :: forall s (m :: * -> *) a. (s -> s) -> StateT s m a -> StateT s m a
trans_withStateT = I.withStateT

type TransState a = I.State a

type TransStateT a b c = I.StateT a b c
