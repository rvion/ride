 -- generated by rvion/jetpack-gen 
module Data.Map.Strict.AsMap where
import Data.Map.Strict

-- ($winsertLookupWithKey) doesn't seem to be exported
-- ($wmapAccumL) doesn't seem to be exported
-- ($wmapAccumRWithKey) doesn't seem to be exported
-- ($wpoly_go) doesn't seem to be exported
-- ($wpoly_go1) doesn't seem to be exported
-- ($wupdateAt) doesn't seem to be exported
-- ($wupdateLookupWithKey) doesn't seem to be exported

map_adjust :: forall a k. Ord k => (a -> a) -> k -> Map k a -> Map k a
map_adjust =  T.adjust

map_adjustWithKey :: forall k a. Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
map_adjustWithKey =  T.adjustWithKey

map_alter :: forall a k.
  Ord k =>
  (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
map_alter =  T.alter

map_differenceWith :: forall a b k.
  Ord k =>
  (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
map_differenceWith =  T.differenceWith

map_differenceWithKey :: forall k a b.
  Ord k =>
  (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
map_differenceWithKey =  T.differenceWithKey

map_findWithDefault :: forall a k. Ord k => a -> k -> Map k a -> a
map_findWithDefault =  T.findWithDefault

map_fromAscList :: forall k a. Eq k => [(k, a)] -> Map k a
map_fromAscList =  T.fromAscList

map_fromAscListWith :: forall a k. Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
map_fromAscListWith =  T.fromAscListWith

map_fromAscListWithKey :: forall k a. Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
map_fromAscListWithKey =  T.fromAscListWithKey

map_fromDistinctAscList :: forall k a. [(k, a)] -> Map k a
map_fromDistinctAscList =  T.fromDistinctAscList

map_fromList :: forall k a. Ord k => [(k, a)] -> Map k a
map_fromList =  T.fromList

map_fromListWith :: forall a k. Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
map_fromListWith =  T.fromListWith

map_fromListWithKey :: forall k a. Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
map_fromListWithKey =  T.fromListWithKey

map_fromSet :: forall k a. (k -> a) -> Set k -> Map k a
map_fromSet =  T.fromSet

map_insert :: forall k a. Ord k => k -> a -> Map k a -> Map k a
map_insert =  T.insert

map_insertLookupWithKey :: forall k a.
  Ord k =>
  (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
map_insertLookupWithKey =  T.insertLookupWithKey

map_insertWith :: forall a k. Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
map_insertWith =  T.insertWith

map_insertWithKey :: forall k a.
  Ord k =>
  (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
map_insertWithKey =  T.insertWithKey

map_intersectionWith :: forall a b c k.
  Ord k =>
  (a -> b -> c) -> Map k a -> Map k b -> Map k c
map_intersectionWith =  T.intersectionWith

map_intersectionWithKey :: forall k a b c.
  Ord k =>
  (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
map_intersectionWithKey =  T.intersectionWithKey

map_map :: forall a b k. (a -> b) -> Map k a -> Map k b
map_map =  T.map

map_mapAccum :: forall a b c k. (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
map_mapAccum =  T.mapAccum
-- (mapAccumL) doesn't seem to be exported

map_mapAccumRWithKey :: forall a k b c.
  (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
map_mapAccumRWithKey =  T.mapAccumRWithKey

map_mapAccumWithKey :: forall a k b c.
  (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
map_mapAccumWithKey =  T.mapAccumWithKey

map_mapEither :: forall a b c k. (a -> Either b c) -> Map k a -> (Map k b, Map k c)
map_mapEither =  T.mapEither
-- (mapEither1) doesn't seem to be exported

map_mapEitherWithKey :: forall k a b c.
  (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)
map_mapEitherWithKey =  T.mapEitherWithKey

map_mapKeysWith :: forall a k1 k2.
  Ord k2 =>
  (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
map_mapKeysWith =  T.mapKeysWith

map_mapMaybe :: forall a b k. (a -> Maybe b) -> Map k a -> Map k b
map_mapMaybe =  T.mapMaybe

map_mapMaybeWithKey :: forall k a b. (k -> a -> Maybe b) -> Map k a -> Map k b
map_mapMaybeWithKey =  T.mapMaybeWithKey

map_mapWithKey :: forall k a b. (k -> a -> b) -> Map k a -> Map k b
map_mapWithKey =  T.mapWithKey

map_mergeWithKey :: forall k a b c.
  Ord k =>
  (k -> a -> b -> Maybe c)
  -> (Map k a -> Map k c)
  -> (Map k b -> Map k c)
  -> Map k a
  -> Map k b
  -> Map k c
map_mergeWithKey =  T.mergeWithKey

map_singleton :: forall k a. k -> a -> Map k a
map_singleton =  T.singleton

map_unionWith :: forall a k. Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
map_unionWith =  T.unionWith

map_unionWithKey :: forall k a.
  Ord k =>
  (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
map_unionWithKey =  T.unionWithKey

map_unionsWith :: forall a k. Ord k => (a -> a -> a) -> [Map k a] -> Map k a
map_unionsWith =  T.unionsWith

map_update :: forall a k. Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
map_update =  T.update

map_updateAt :: forall k a. (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
map_updateAt =  T.updateAt

map_updateLookupWithKey :: forall k a.
  Ord k =>
  (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
map_updateLookupWithKey =  T.updateLookupWithKey

map_updateMax :: forall a k. (a -> Maybe a) -> Map k a -> Map k a
map_updateMax =  T.updateMax

map_updateMaxWithKey :: forall k a. (k -> a -> Maybe a) -> Map k a -> Map k a
map_updateMaxWithKey =  T.updateMaxWithKey
-- (updateMaxWithKey_$supdateMaxWithKey) doesn't seem to be exported

map_updateMin :: forall a k. (a -> Maybe a) -> Map k a -> Map k a
map_updateMin =  T.updateMin

map_updateMinWithKey :: forall k a. (k -> a -> Maybe a) -> Map k a -> Map k a
map_updateMinWithKey =  T.updateMinWithKey
-- (updateMinWithKey_$supdateMinWithKey) doesn't seem to be exported

map_updateWithKey :: forall k a. Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
map_updateWithKey =  T.updateWithKey
