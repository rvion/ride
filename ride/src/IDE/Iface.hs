{-# LANGUAGE StandaloneDeriving, NamedFieldPuns #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE BangPatterns,Rank2Types #-}

module IDE.Iface where

import Avail -- https://github.com/ghc/ghc/blob/master/compiler/basicTypes/Avail.hs#L37
import BinIface
import Control.Monad (forM)
import Data.Char (toLower, toUpper, isLower, isUpper)
import Name
import Data.List
import Data.Maybe
import Data.String.Utils
import DynFlags
import GHC
import GHC.Paths ( libdir )
import IDE.Types
import IfaceSyn  -- (ifType, ifName)
import Outputable -- https://github.com/ghc/ghc/blob/8c5fe53b411d83279fea44f89538a7265b1275ff/compiler/utils/Outputable.hs
import qualified Data.Map as Map
import System.Directory (createDirectoryIfMissing)
import System.IO
import TcRnMonad
import Data.Map (Map)

type Renderer = SDoc -> String
type IfaceDeclMap = Map String IfaceDecl

getIface :: String -> Ghc ModIface
getIface hiFilepath = do
  sess <- getSession
  liftIO $ initTcRnIf 's' sess () () $
    readBinIface IgnoreHiWay QuietBinIFaceReading hiFilepath

-- getIfaceDecl :: Renderer -> Name -> ModIface -> IfaceDecl
-- getIfaceDecl toS name modIface =
--   let modIfaceMap = mkIfaceDeclMap toS modIface
--   in  modIfaceMap Map.! (toS.ppr$name)

mkIfaceDeclMap :: Renderer -> ModIface -> IfaceDeclMap
mkIfaceDeclMap toS iface =
  Map.fromList (map toTupple ifaceDecls)
  where
    toTupple ifaceDecl = (nameAsString ifaceDecl, ifaceDecl)
    ifaceDecls = map snd $ mi_decls iface
    nameAsString = toS . ppr . ifName

printReexports :: (String, String, Modules) -> [String] -> IO [String]
printReexports (prefix, mod, modules) previouslyExportedSymbols = whenValid prefix
  defaultErrorHandler defaultFatalMessager defaultFlushOut $ do
    -- Init GHC compiler
    runGhc (Just libdir) $ do
      dflags <- getSessionDynFlags
      pkgs   <- setSessionDynFlags dflags
      sess   <- getSession

      -- define context-dependant helper functions
      let
        toSDoc :: SDoc -> String
        toSDoc = showSDoc dflags

        toS :: Outputable a => a -> String
        toS = toSDoc . ppr

      -- load the initial .hi interface file
      iface <- getIface (modules Map.! mod)

      let
        -- we want to reexport all IfacesExport,
        ifaceExports = mi_exports iface
        exportedSymbols = concatMap extractAllNames ifaceExports
        decls = mi_decls iface
        declsMap = mkIfaceDeclMap toSDoc iface

        moduleName = toS $ mi_module iface
        jetpackFolder = "jetpack/src/"
        _folders = jetpackFolder ++ (replace "." "/" moduleName)
          -- let parts = splitOn "." moduleName
          -- in (concat$ intersperse "/" (init parts), last parts)
        (p:ps) = prefix
        sep = "_"
        _idPrefix = (toLower p : ps)
        _typePrefix = (toUpper p : ps)
        _fileName = concat ["As", _typePrefix]
        _filePath = (_folders ++ "/" ++ _fileName ++ ".hs")

      liftIO.print$concat ["exports are ",toS exportedSymbols]
      declsF <- forM exportedSymbols $ \name -> do
        liftIO$print ("trying to find "++toS name)
        let
          _name = toS name
          _success ifaceDecl = return (name, Just ifaceDecl)
          _fail = do
            liftIO.print.concat$["  warn: impossible to find decl for (",toS name,")"]
            return (name, Nothing)

        case Map.lookup _name declsMap of
          Just ifaceDecl -> _success ifaceDecl
          Nothing -> case (toS <$> nameModule_maybe name) of
            Just nameModule -> do -- eg: Data.Either
              liftIO $ putStrLn ("  - loading "++ nameModule)
              otherIface <- getIface (modules Map.! nameModule)
              let _otherIfaceMap = mkIfaceDeclMap toSDoc otherIface
              case Map.lookup _name _otherIfaceMap of
                Just otherIfaceDecl -> _success otherIfaceDecl
                Nothing -> _fail
            Nothing -> _fail

      liftIO $ print$toS declsF


      liftIO $ createDirectoryIfMissing True _folders

      liftIO $ withFile _filePath WriteMode $ \fileHandle -> do
        let put = hPutStrLn fileHandle . concat
        put $
          [ "module ",moduleName,".", _fileName ," where"
          , "\n-- generated by rvion/jetpack-gen ", "\n"
          , "\n", "import ", moduleName, " as I"
          , "\n"
          ]

        newDecl <- (flip mapM) exportedSymbols $ \_ghcName -> do
          let
            _name = toS _ghcName
            _reexported_name = concat [_idPrefix, sep, _name]
            _reexported_type = concat [_typePrefix, _name]
            -- _type = typeSdoc decl

          case () of
            () | isJust ((mi_warn_fn iface) _ghcName) ->  do
                    putStrLn $ concat ["  warn: (",_reexported_name,") not exported because it is deprecated"]
                    return Nothing
               | (_reexported_name `elem` previouslyExportedSymbols) -> do
                    putStrLn $ concat ["  warn: (",_reexported_name, ") previously exported"]
                    return Nothing
                  -- | not (_name `elem` exportedSymbols) -> do
                  -- putStrLn $ concat ["  warn: ", _name, " is not exported by current module"]
                  -- return Nothing
               | (head _name) `elem` operators -> do
                    -- putStrLn $ concat ["  warn: (", _name, ") is not reexported because it is an operator"]
                    if (_name `elem` previouslyExportedSymbols)
                      then do
                        putStrLn $ concat ["  warn: operator (",_name, ") previously exported"]
                        return Nothing
                      else do
                        put ["(",_name,")", " = (I.", _name,")"]
                        print _name
                        return (Just _name)

               | isLower (head _name) || (head _name) == '_' -> do
                    put [_reexported_name, " = I.", _name]
                    return (Just _reexported_name)
               | isUpper (head _name) -> do
                   case Map.lookup _name declsMap of
                      Just IfaceSynonym{ifTyVars} -> do
                        -- print ((toS.ppr$showIfaceKind xxx )++ (toS$ showIfaceInfo xxx))
                        -- print (toS.ppr$xxx)
                        let tyVars = intersperse ' ' $ take (length ifTyVars) ['a'..'z']
                        put ["type ", _reexported_type," ",tyVars, " = I.", _name, " ",tyVars]
                        return (Just _reexported_type) -- tyvars needed because type synonym must be instanciated
                      _  -> do
                        put ["type ", _reexported_type, " = I.", _name, " -- not declared in module, :/ ? "]
                        return (Just _reexported_type)
               | otherwise -> do
                    -- put $ case decl of
                    --   IfaceId{} ->
                    -- ["\n", _idPrefix, sep, _name, " :: ", replace "\n" "\n  " (toS _type)
                    -- put [_reexported_name, " = I.", _name]
                    -- IfaceData{} ->
                    -- put ["type ", _typePrefix,sep, _name, " = I.", _name]
                    -- return (Just _reexported_name)
                    return Nothing
                    -- IfaceSynonym{} -> ["-- (",_name,") :: IfaceSynonym -> NOT YET SUPPORTED"]
                    -- IfaceFamily{} -> ["-- (",_name,") :: IfaceFamily -> NOT YET SUPPORTED"]
                    -- IfaceClass{} -> ["-- (",_name,") :: IfaceClass -> NOT YET SUPPORTED"]
                    -- IfaceAxiom{} -> ["-- (",_name,") :: IfaceAxiom -> NOT YET SUPPORTED"]
                    -- IfacePatSyn{} -> ["-- (",_name,") :: IfacePatSyn -> NOT YET SUPPORTED"]
        -- print (previouslyExportedSymbols)
        return (previouslyExportedSymbols ++ (catMaybes newDecl))


typeSdoc :: IfaceDecl -> SDoc
typeSdoc x =
  if isIfaceId x
    then ppr (ifType x)
    else ppr "-"

isIfaceId (IfaceId{}) = True
isIfaceId _ = False

showIfaceKind :: IfaceDecl -> String
showIfaceKind x = case x of
  IfaceId{} -> "IfaceId"
  IfaceData{} -> "IfaceData"
  IfaceSynonym{ifTyVars} -> "IfaceSynonym: "
  IfaceFamily{} -> "IfaceFamily"
  IfaceClass{} -> "IfaceClass"
  IfaceAxiom{} -> "IfaceAxiom"
  IfacePatSyn{} -> "IfacePatSyn"
          -- _ -> "ERROR"

showIfaceInfo :: IfaceDecl -> SDoc
showIfaceInfo x = case x of
  IfaceId{} -> ppr "IfaceId"
  IfaceData{} -> ppr "IfaceData"
  IfaceSynonym{ifTyVars} -> ppr ifTyVars
  IfaceFamily{} -> ppr "IfaceFamily"
  IfaceClass{} -> ppr "IfaceClass"
  IfaceAxiom{} -> ppr "IfaceAxiom"
  IfacePatSyn{} -> ppr "IfacePatSyn"

for :: [a] -> (a->b) -> [b]
for = flip map

operators :: String
operators = ['!','#','$','%','&','*','+','.','/','<','=','>','?','@','\\','^','|','-','~',':']



pretify :: Renderer -> AvailInfo -> [String]
pretify toS exportedName = case exportedName of
 Avail n -> [asString n]
 AvailTC x [] -> []
 AvailTC x xs -> nub (asString x:(map asString xs))
 where asString = toS . ppr

-- pretify :: Renderer -> AvailInfo -> [String]
-- pretify toS exportedName = case exportedName of
--  Avail n -> [asString n]
--  AvailTC x [] -> []
--  AvailTC x xs -> if x == head xs then [asString x] else []
--  where asString = toS . ppr

extractAllNames :: AvailInfo -> [Name]
extractAllNames ai = case ai of
 Avail n -> [n]
 AvailTC x xs -> [x] -- :xs -- TODO

whenValid "" = error "prefix can't be empty"
whenValid x =
  if all (`elem` ('_':['a'..'z']++['A'..'Z'])) x
    then id
    else error "invalid chars"

-- test = printReexports ("lens", "/Users/RemiVion/.stack/snapshots/x86_64-osx/nightly-2015-11-29/7.10.2/lib/x86_64-osx-ghc-7.10.2/microlens-platform-0.1.5.0-GZu1yvU44tYD8BDHxEQWch/Lens/Micro/Platform.hi") []

-- import Binary -- https://github.com/ghc/ghc/blob/master/compiler/utils/Binary.hs
-- import Control.Monad (forM_)
-- import Control.Monad.IO.Class(liftIO)
-- import Data.List (intersperse)
-- import Data.List.Split
-- import DynFlags (defaultDynFlags)
-- import GHC.PackageDb -- https://github.com/ghc/ghc/blob/master/libraries/ghc-boot/GHC/PackageDb.hs#L140
-- import HscTypes -- https://github.com/ghc/ghc/blob/master/compiler/main/HscTypes.hs#L725
-- import IDE.NameInfos
-- import LoadIface
-- import Module -- https://github.com/ghc/ghc/blob/master/compiler/basicTypes/Module.hs#L248
-- import Name -- https://github.com/ghc/ghc/blob/master/compiler/basicTypes/Name.hs#L37
-- import Outputable (dot)

-- http://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-7.10.2/LoadIface.html

-- fp :: FilePath
-- fp = "/Users/rvion/.stack/snapshots/x86_64-osx/nightly-2015-11-29/7.10.2/lib/x86_64-osx-ghc-7.10.2/text-1.2.1.3-1l1AN4I48k37RaQ6fm6CEh/Data/Text.hi"
-- fp = "/Users/rvion/.stack/snapshots/x86_64-osx/nightly-2015-11-29/7.10.2/lib/x86_64-osx-ghc-7.10.2/tagged-0.8.2-4zanMqQLQHpBO0ZYm7KGkc/Data/Tagged.hi"
-- fp = "/Users/rvion/.stack/snapshots/x86_64-osx/nightly-2015-11-29/7.10.2/lib/x86_64-osx-ghc-7.10.2/zlib-0.5.4.2-7EfFFsXSCF6JCVS3xlYBS8/Codec/Compression/Zlib/Raw.hi"
-- fp = "/Users/rvion/.stack/snapshots/x86_64-osx/nightly-2015-11-10/7.10.2/lib/x86_64-osx-ghc-7.10.2/text-1.2.1.3-1l1AN4I48k37RaQ6fm6CEh/Data/Text.hi"


-- DEBUG
--------
-- let a = (concatMap extractAllNames exports)
-- liftIO $ print $ length exports
-- liftIO $ forM_ exports $ \exp -> do
--   putStrLn $ toS (vcat $ concatMap getNameInfos (extractAllNames exp))
--   putStrLn "--------"



-- liftIO $ print $ toS $ (map getNameInfos

-- should we import the module qualified to avoid clashes with prelude ?
-- if so, type signatures might not work anymore.
-- are they working as of now anyway ?
-- liftIO $ writeFile _filePath ""
-- liftIO $ print (_folders,_file)
