module Gen.Modules where

import           Control.Monad     (forM)
import           Data.Char         (isLower, toLower, toUpper)
import           Data.List
import           Data.Maybe
import           Data.String.Utils
import           Gen.Types
import           System.Directory  (createDirectoryIfMissing)
import           System.IO


whenValid "" = error "prefix can't be empty"
whenValid x =
  if all (`elem` ('_':['a'..'z']++['A'..'Z'])) x
    then id
    else error "invalid chars"

-- printReexports
printReexports :: (String, String) -> [RTerm] -> [String] -> IO [String]
printReexports (mod, prefix) reexports previouslyExportedSymbols = do
  let
    moduleName = mod -- TODO
    _folders = jetpackLibFolder ++ replace "." "/" moduleName
      -- let parts = splitOn "." moduleName
      -- in (concat$ intersperse "/" (init parts), last parts)
    (p:ps) = prefix
    sep = "_"
    _idPrefix = toLower p : ps
    _typePrefix = toUpper p : ps
    _fileName = "As" ++ _typePrefix
    _filePath = _folders ++ "/" ++ _fileName ++ ".hs"

  createDirectoryIfMissing True _folders
  withFile _filePath WriteMode $ \fileHandle -> do
    let put = hPutStrLn fileHandle . concat

    put
      [ "module ",moduleName,".", _fileName ," where"
      , "\n-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen"
      , "\n\nimport ", moduleName, " as I"
      , "\n"
      ]

    newDecl <- forM reexports $ \rTerm -> do
      let
        _name = rName rTerm
        _reexported_name =
          if head _name `elem` operators
            then _name
            else concat [_idPrefix, sep, _name]
        _reexported_type = _typePrefix ++ _name
        -- _type = typeSdoc decl

      case rTerm of
        RId _ rType
          | _reexported_name `elem` previouslyExportedSymbols -> do
              putStrLn $ concat ["  warn: (",_reexported_name, ") previously exported"]
              return Nothing
          | head _name `elem` operators -> do
              put ["-- (",_name,") :: ",rType]
              put ["(",_name,")", " = (I.", _name,")\n"]
              return (Just _reexported_name)
          | isLower (head _name) || head _name == '_' -> do
              put ["-- ",_reexported_name," :: ",rType]
              put [_reexported_name, " = I.", _name,"\n"]
              return (Just _reexported_name)
          | otherwise -> error "ahaha"
        RData _ rType nbTyVars
          | _reexported_type `elem` previouslyExportedSymbols -> do
              putStrLn $ concat ["  warn: (",_reexported_name, ") previously exported"]
              return Nothing
          | otherwise -> do
              let tyVars = intersperse ' ' $ take nbTyVars ['a'..'z']
              -- put ["-- ",_reexported_type," :: ",rType]
              put (["type ", _reexported_type," ",tyVars, " = I.", _name] ++ (if nbTyVars > 0 then [" ",tyVars] else []))
              return (Just _reexported_type) -- tyvars needed because type synonym must be instanciated
    -- print (previouslyExportedSymbols)
    return (previouslyExportedSymbols ++ catMaybes newDecl)

-- handleDeprecated :: RTerm -> IO (Maybe String)
-- handleDeprecated rTerm = do
--   putStrLn $ concat ["  warn: (",_reexported_name,") not exported because it is deprecated"]
--   return Nothing

operators :: String
operators = ['!','#','$','%','&','*','+','.','/','<','=','>','?','@','\\','^','|','-','~',':']


-- liftIO $ mapM_ (putStrLn.(" -> "++).toS) declsF

