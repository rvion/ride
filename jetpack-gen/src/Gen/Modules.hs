{-# LANGUAGE RecordWildCards #-}
module Gen.Modules where

import           Control.Monad     (forM)
import           Data.Char         (isLower, toLower, toUpper)
import           Data.List
import           Data.Maybe
import           Data.String.Utils
import           Gen.Types
import           System.Directory  (createDirectoryIfMissing)
import           System.IO


whenValid "" = error "prefix can't be empty"
whenValid x =
  if all (`elem` ('_':['a'..'z']++['A'..'Z'])) x
    then id
    else error "invalid chars"

-- printReexports
printReexports :: (String, String) -> [RTerm] -> [String] -> IO [String]
printReexports (mod, prefix) reexports previouslyExportedSymbols = do
  let
    moduleName = mod -- TODO
    _folders = jetpackLibFolder ++ replace "." "/" moduleName
      -- let parts = splitOn "." moduleName
      -- in (concat$ intersperse "/" (init parts), last parts)
    (p:ps) = prefix
    sep = "_"
    _idPrefix = (toLower p : ps) ++ sep
    _typePrefix = toUpper p : ps
    _fileName = "As" ++ _typePrefix
    _filePath = _folders ++ "/" ++ _fileName ++ ".hs"

  createDirectoryIfMissing True _folders
  withFile _filePath WriteMode $ \fileHandle -> do
    let put = hPutStrLn fileHandle . concat

    put
      [ "module ",moduleName,".", _fileName ," where"
      , "\n-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen"
      , "\n\nimport qualified ", moduleName, " as I"
      , "\n"
      ]

    newDecl <- forM reexports $ \rTerm -> do

      let
        -- core reexport codegen
        reexportFn x = do
          let
            _name = rName x
            _reexported_name =
              if head _name `elem` operators
                then _name
                else _idPrefix ++ _name
            _reexported_type = _typePrefix ++ _name
            -- _type = typeSdoc decl
          case x of
            RId _ rType
              | _reexported_name `elem` previouslyExportedSymbols -> do
                  putStrLn $ concat ["  warn: (",_reexported_name, ") previously exported"]
                  return [Nothing]
              | head _name `elem` operators -> do
                  put ["\n-- (",_name,") :: ",rType]
                  put ["(",_name,")", " = (I.", _name,")"]
                  return [Just _reexported_name]
              | isLower (head _name) || head _name == '_' -> do
                  put ["\n-- ",_reexported_name," :: ",rType]
                  put [_reexported_name, " = I.", _name]
                  return [Just _reexported_name]
              | otherwise -> error ("ahaha " ++ _name)
            RData _ rType nbTyVars rDataTyCons
              | _reexported_type `elem` previouslyExportedSymbols -> do
                  putStrLn $ concat ["  warn: (",_reexported_name, ") previously exported"]
                  return [Nothing]
              | otherwise -> do
                  let tyVars = intersperse ' ' $ take nbTyVars ['a'..'z']
                  -- put ["-- ",_reexported_type," :: ",rType]
                  put (["\ntype ", _reexported_type," ",tyVars, " = I.", _name] ++ (if nbTyVars > 0 then [" ",tyVars] else []))
                  exportedCons <- concat <$> forM rDataTyCons reexportFn
                  return (Just _reexported_type:exportedCons) -- tyvars needed because type synonym must be instanciated
            RDataCon{..}
              | head rName `elem` operators -> do
                  putStrLn $ concat ["  warn: (",rName, ") as a type constructor is not yet supported"]
                  return [Nothing]
              | otherwise -> do
                  let tyVars = intersperse ' ' $ take rNbTyVars ['a'..'z']
                  let constrType = intercalate " -> " (rTyVars ++ [rName])
                  let conName = concat [_idPrefix,"mk'", rName]
                  let patName = _typePrefix ++ rName
                  put ["\n-- constructor :: ", constrType]
                  put [conName, " =  I.", rName]
                  put ["pattern ", patName, " ", tyVars, " <-  I.", rName, " ", tyVars]
                  return [Just conName, Just ("pattern " ++ patName)]
            RClass n fns ->
              concat <$> forM fns reexportFn

      reexportFn rTerm
    -- print (previouslyExportedSymbols)
    return (previouslyExportedSymbols ++ catMaybes(concat newDecl))

-- handleDeprecated :: RTerm -> IO (Maybe String)
-- handleDeprecated rTerm = do
--   putStrLn $ concat ["  warn: (",_reexported_name,") not exported because it is deprecated"]
--   return Nothing

operators :: String
operators = ['!','#','$','%','&','*','+','.','/','<','=','>','?','@','\\','^','|','-','~',':']


-- liftIO $ mapM_ (putStrLn.(" -> "++).toS) declsF

-- data G = G1 Int
-- pattern JsG1 <- G1
-- mkG1 = G1
