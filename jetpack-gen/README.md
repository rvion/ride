# jetpack-gen:

:warning: WIP
Please, __don't post anything on reddit for now__.


PatternSynonyms https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html
Pattern synonyms are enabled by the flag -XPatternSynonyms, which is required for defining them, but not for using them


not possible to match and build Data with same keyword for now
will be fixed with ghc8 see also https://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html


LiberalTypeSynonyms is needed for partial types synonim such as 
```haskell
type M = TransStateT Ctx IO
```

getters and setters

draback: used as a library might be annoying because jetpack are more likely not to compile when deps change

### Input

```
m Data.Map.Strict
```

### output

```haskell
module Data.Map.Strict.AsM where
-- generated by https://github.com/rvion/ride/tree/master/jetpack-gen

import Data.Map.Strict as I

-- (!) :: forall k a. Ord k => Map k a -> k -> a
(!) = (I.!)

-- (\\) :: forall k a b. Ord k => Map k a -> Map k b -> Map k a
(\\) = (I.\\)

-- m_assocs :: forall k a. Map k a -> [(k, a)]
m_assocs = I.assocs

-- m_delete :: forall k a. Ord k => k -> Map k a -> Map k a
m_delete = I.delete

-- m_deleteAt :: forall k a. Int -> Map k a -> Map k a
m_deleteAt = I.deleteAt

-- m_deleteFindMax :: forall k a. Map k a -> ((k, a), Map k a)
m_deleteFindMax = I.deleteFindMax

[...]
```

## Usages

 - per project framework including all functions
 - generate practical export bindings for a local project

## Necessary Extensions

 - MagicHash to be able to reexport symbols ending with a Hash (like t_unpackCString# from Data.Text)
 - rankNtypes to handle complicated types found in `Conduit` or `Microlens`
 - DataKinds to be able to reexport prefixed promoted data kinds
 - FlexibleContexts to be able to handle aliasing [Those kinds of types](http://stackoverflow.com/questions/27895196/haskell-illegal-polymorphic-type)
 - NoMonomorphismRestriction 

:memo: available typeclass export info is really not practical to use! 

-------------

some next steps:
  - [ ] remove the need to manually specify packages !
  - [ ] don't warn when reexport same occName, because it only means it is the same symbol. better would be to warn when same name for other occName 
  - [ ] remove the need to manually install packages !
  - [ ] ensure packages are not declared twice with the same reexport name, or it will result in blank file
  - [ ] cache even more module loading (per run)
  - [ ] ensure all necessary packages are installed
  - [ ] export promoted kind aliases
  - [ ] ensure we don't reexport twice the same getter or setter
  - [ ] document https://ghc.haskell.org/trac/ghc/wiki/ModuleReexports
  - [ ] document backpack
  - [X] cache module loading per import
  - [X] re-handle deprecated types
  - [x] show commented types above each definitions
  - [x] check how to deal with http://stackoverflow.com/questions/27895196/haskell-illegal-polymorphic-type makes it hard


