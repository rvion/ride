{-#LANGUAGE StandaloneDeriving#-}
{-#LANGUAGE TypeSynonymInstances#-}
{-#LANGUAGE GeneralizedNewtypeDeriving#-}
{-#LANGUAGE BangPatterns#-}

module IDE.Iface where

-- [ ] mention https://ghc.haskell.org/trac/ghc/wiki/ModuleReexports
-- [ ] mention backpack
import System.IO
import GHC.PackageDb -- https://github.com/ghc/ghc/blob/master/libraries/ghc-boot/GHC/PackageDb.hs#L140
import Binary -- https://github.com/ghc/ghc/blob/master/compiler/utils/Binary.hs
import HscTypes -- https://github.com/ghc/ghc/blob/master/compiler/main/HscTypes.hs#L725
import Avail -- https://github.com/ghc/ghc/blob/master/compiler/basicTypes/Avail.hs#L37
import Name -- https://github.com/ghc/ghc/blob/master/compiler/basicTypes/Name.hs#L37
import Module -- https://github.com/ghc/ghc/blob/master/compiler/basicTypes/Module.hs#L248
import LoadIface
import GHC
import GHC.Paths ( libdir )
import DynFlags
import Control.Monad.IO.Class(liftIO)
import Outputable (dot)
import Data.List.Split
import Outputable -- https://github.com/ghc/ghc/blob/8c5fe53b411d83279fea44f89538a7265b1275ff/compiler/utils/Outputable.hs
import DynFlags (defaultDynFlags)
import BinIface
import TcRnMonad
import IfaceSyn  -- (ifType, ifName)
import Control.Monad (forM_)
import Data.Char (toLower, toUpper)
import System.Directory (createDirectoryIfMissing)
import Data.List (intersperse)
import Data.String.Utils
-- import Data.Tuple.Extra (both)
both f (a,b) = (f a, f b)

text_Just = Just

type Renderer = SDoc -> String

pretify :: Renderer -> AvailInfo -> [String]
pretify toS exportedName = case exportedName of
 Avail n -> [asString n]
 AvailTC _ xs -> map asString xs
 where asString = toS . ppr

whenValid "" = error "prefix can't be empty"
whenValid x =
  if all (`elem` (['a'..'z']++['A'..'Z'])) x
    then id
    else error "invalid chars"

printReexports :: (String, String) -> IO ()
printReexports (prefix, hiFilepath) = whenValid prefix
  defaultErrorHandler defaultFatalMessager defaultFlushOut $ do
    runGhc (Just libdir) $ do
      dflags <- getSessionDynFlags
      pkgs   <- setSessionDynFlags dflags
      sess   <- getSession

      -- load .hi interface file
      iface <- liftIO $ initTcRnIf 's' sess () () $
         readBinIface IgnoreHiWay QuietBinIFaceReading hiFilepath

      let
        toS :: SDoc -> String
        toS = showSDoc dflags
        exports = mi_exports iface
        exportedSymbols = concatMap (pretify toS) exports
        decls =  map snd $ mi_decls iface
        moduleName = toS.ppr $ mi_module iface
        jetpackFolder = "jetpack/src/"
        _folders = jetpackFolder ++ (replace "." "/" moduleName)
          -- let parts = splitOn "." moduleName
          -- in (concat$ intersperse "/" (init parts), last parts)
        (p:ps) = prefix
        sep = "_"
        _idPrefix = (toLower p : ps)
        _typePrefix = (toUpper p : ps)
        _fileName = concat ["As", _typePrefix]
        _filePath = (_folders ++ "/" ++ _fileName ++ ".hs")

      -- should we import the module qualified to avoid clashes with prelude ?
      -- if so, type signatures might not work anymore.
      -- are they working as of now anyway ?
      -- liftIO $ writeFile _filePath ""
      -- liftIO $ print (_folders,_file)
      liftIO $ createDirectoryIfMissing True _folders

      liftIO $ withFile _filePath WriteMode $ \fileHandle -> do
        let writeInFile = hPutStrLn fileHandle
        writeInFile . concat $
          [ "-- generated by rvion/jetpack-gen ", "\n"
          , "module ", _fileName ," where"
          , "\n", "import ", moduleName
          , "\n"
          ]

        -- http://haddock.stackage.org/nightly-2015-12-09/ghc-7.10.2/GHC.html#t:ModIface
        -- http://haddock.stackage.org/nightly-2015-12-09/ghc-7.10.2/IfaceSyn.html#t:IfaceDecl
        forM_ decls $ \decl -> do
          let
            _name = ppr (ifName decl)
            _type = typeSdoc decl

          writeInFile . concat $
            if not (toS _name `elem` exportedSymbols)
            then ["-- (",toS _name, ") doesn't seem to be exported"]
            else case decl of
              IfaceId{} ->
                ["\n", _idPrefix, sep, toS _name, " :: ", replace "\n" "\n  " (toS _type)
                ,"\n", _idPrefix, sep, toS _name, " =  T.", toS _name]
              IfaceData{} ->
                ["\n", "type ", _typePrefix,sep, toS _name, " = T.", toS _name]
              IfaceSynonym{} -> ["-- (",toS _name,") :: IfaceSynonym -> NOT YET SUPPORTED"]
              IfaceFamily{} -> ["-- (",toS _name,") :: IfaceFamily -> NOT YET SUPPORTED"]
              IfaceClass{} -> ["-- (",toS _name,") :: IfaceClass -> NOT YET SUPPORTED"]
              IfaceAxiom{} -> ["-- (",toS _name,") :: IfaceAxiom -> NOT YET SUPPORTED"]
              IfacePatSyn{} -> ["-- (",toS _name,") :: IfacePatSyn -> NOT YET SUPPORTED"]
        -- writeFile
        -- print exportedSymbols


typeSdoc :: IfaceDecl -> SDoc
typeSdoc x =
  if isIfaceId x
    then ppr (ifType x)
    else ppr "-"

isIfaceId (IfaceId{}) = True
isIfaceId _ = False

showIfaceConstr x = case x of
  IfaceId{} -> "IfaceId"
  IfaceData{} -> "IfaceData"
  IfaceSynonym{} -> "IfaceSynonym"
  IfaceFamily{} -> "IfaceFamily"
  IfaceClass{} -> "IfaceClass"
  IfaceAxiom{} -> "IfaceAxiom"
  IfacePatSyn{} -> "IfacePatSyn"
          -- _ -> "ERROR"


-- http://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-7.10.2/LoadIface.html

-- fp :: FilePath
-- fp = "/Users/rvion/.stack/snapshots/x86_64-osx/nightly-2015-11-29/7.10.2/lib/x86_64-osx-ghc-7.10.2/text-1.2.1.3-1l1AN4I48k37RaQ6fm6CEh/Data/Text.hi"
-- fp = "/Users/rvion/.stack/snapshots/x86_64-osx/nightly-2015-11-29/7.10.2/lib/x86_64-osx-ghc-7.10.2/tagged-0.8.2-4zanMqQLQHpBO0ZYm7KGkc/Data/Tagged.hi"
-- fp = "/Users/rvion/.stack/snapshots/x86_64-osx/nightly-2015-11-29/7.10.2/lib/x86_64-osx-ghc-7.10.2/zlib-0.5.4.2-7EfFFsXSCF6JCVS3xlYBS8/Codec/Compression/Zlib/Raw.hi"
-- fp = "/Users/rvion/.stack/snapshots/x86_64-osx/nightly-2015-11-10/7.10.2/lib/x86_64-osx-ghc-7.10.2/text-1.2.1.3-1l1AN4I48k37RaQ6fm6CEh/Data/Text.hi"

-- c :: IO ModIface
-- c = do
--   binHandle <- readBinMem fp
--   !a <- get binHandle
--   return a

-- d :: IO [AvailInfo] -- IO [IfaceExport]
-- d = mi_module <$> c
-- showSDoc

-- e = d >>= print.(showSDocUnsafe.ppr).head


-- instance Show ModuleName
--   where show a = show (toStringRep a)

-- instance Show Module where
--   show = show.toStringRep.moduleName
-- deriving instance Show Module
-- deriving instance Show Name
-- deriving instance Show IfaceExport

-- myShow x = show (mi_module x)
-- myshowforName a = case a of
--   Avail  name -> show name
--   AvailTC name fieldLabels -> show name
for = flip map
